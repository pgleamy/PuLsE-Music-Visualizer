<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">


<!-- Basic example CSP: restricts most resources to 'self' and a few trusted CDNs -->
<meta
  http-equiv="Content-Security-Policy"
  content="
    default-src 'self';
    script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline';
    style-src   'self' 'unsafe-inline' https://cdn.jsdelivr.net;
    img-src     'self' data: https:;
    connect-src 'self';
    frame-src   'none';
  "
/>




  <title>PuLsE v.11.3.1</title>
  <!-- Three.js r154 Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
    }
  }
  </script>

  <style>



/* Modal for Slideshow Exit Confirmation */
#slideshowExitModal {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(50, 50, 50, 0.9);
  color: #fff;
  padding: 20px;
  border-radius: 8px;
  z-index: 1000;
  text-align: center;
  font-size: 14px;
}
#slideshowExitModal button {
  margin: 10px 5px;
  padding: 5px 15px;
  background: #555;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
#slideshowExitModal button:hover {
  background: #777;
}
#countdownTimer {
  font-size: 12px;
  margin-top: 10px;
}




    /* CSS */
    body.hide-cursor { cursor: none; }
    body, html {
      margin: 0; padding: 0; overflow: hidden;
      background-color: #000; font-family: sans-serif;
      transition: opacity 0.3s ease;
    }
    canvas { display: block; }
    /* Control Panel styling */
    #controlPanel {
      position: fixed; top: 0; left: 0; width: 250px; max-height: 100%;
      background: rgba(50, 50, 50, 0); color: #fff; overflow-y: auto;
      transition: opacity 0.3s ease, transform 0.3s ease;
      transform: translateX(-150px); opacity: 0; z-index: 10;
      padding: 5px; box-sizing: border-box;
    }
    #controlPanel:hover { transform: translateX(0); opacity: 1; }
    .moduleHeader {
      background: #333; padding: 6px 3px; margin: 3px 0;
      cursor: pointer; font-size: 11px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .moduleContent {
      display: none; padding: 3px; background: #444; margin-bottom: 3px; font-size: 10px;
    }
    .controlElement { margin: 4px 0; }
    .controlElement label { display: flex; margin-bottom: 2px; }
    /* Favorite Settings styles */
    #favoriteSettingsSection { border-top: 1px solid #666; padding-top: 4px; margin-top: 5px; }
    /* New Favorites dropdown styling */
    #toggleFavoriteList {
      width: 100%;
      background: #555;
      color: #fff;
      padding: 4px 8px;
      margin: 4px 0;
      font-size: 11px;
      border: none;
      cursor: pointer;
    }
    #favoriteListContainer {
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.3s ease;
    }
    #favoriteListContainer.open {
      max-height: none;
      overflow-y: auto;
    }
    #favoriteList { list-style: none; padding: 0; margin: 0; }
    #favoriteList li {
      margin: 3px 0; display: flex; justify-content: space-between; align-items: center;
    }
#favoriteList li img {
  width: 50px;
  height: 32px;
  object-fit: cover; /* Ensures the image fills the space without distortion */
  border-radius: 4px; /* Optional: adds rounded corners */
  display: block;
}
#favoriteList li span {
  flex-grow: 1; /* Allows text to take up remaining space */
  margin-right: 5px;
}

    #favoriteList button { margin-left: 3px; font-size: 10px; padding: 2px 3px; }
    
    /* New Slideshow Controls styling */
    #slideshowControls {
      margin: 8px 0;
      padding: 4px;
      background: #444;
      border: 1px solid #666;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      font-size: 11px;
    }
    #slideshowControls button {
      margin-bottom: 4px;
    }
    #slideshowOptions {
      display: flex;
      justify-content: space-between;
    }
    #slideshowOptions label {
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
<!-- Control Panel -->
<div id="controlPanel">
  <!-- Global Settings Panel -->
<div class="moduleHeader" data-target="globalSettings" style="position: relative; background: #2b2b2b;">
    <span>PuLsE Globals</span>
    <span id="fpsDisplay" style="position: absolute; right: 5px; font-size: 11px; color: #fff;">FPS: 0</span>
  </div>

  <div id="globalSettings" class="moduleContent">
    <!-- Fullscreen Checkbox and About Button -->
    <div class="controlElement" style="display: flex; justify-content: space-between; align-items: center;">
      <label style="margin: 0;">
        <input type="checkbox" id="fullscreenToggle"> Fullscreen
      </label>
      <button id="aboutButton" style="background: #555; color: #fff; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer;">About PuLsE</button>
    </div>

    <!-- Screen Stays Active Checkbox -->
    <div class="controlElement">
      <label>
        <input type="checkbox" id="screenStaysActive" /> Screen stays active
      </label>
    </div>

    <!-- Documentation Button -->
    <div class="controlElement">
      <button id="documentationButton" style="background: #555; color: #fff; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer;">Documentation</button>
    </div>
   <div class="controlElement" style="display: flex; justify-content: space-between; align-items: center;">
     <span id="pointCountDisplay">40,000 pts</span>
     <input type="range" id="globalPointCount" min="10000" max="1000000" step="100" value="40000" style="width: 150px;">
   </div>
    <div class="controlElement">
      <label>Disk Size:
        <input type="range" id="globalSphereSize" min="0.1" max="2.5" step="0.001" value="1">
      </label>
    </div>
    <div class="controlElement" style="display: flex; justify-content: space-between; align-items: center;">
      <span id="globalSpeedDisplay">Global Speed 1.00</span>
      <input type="range" id="globalSpeed" min="-3" max="3" step="0.001" value="1" style="width: 150px;">
    </div>

    <div class="controlElement">
      <label>
        <input type="checkbox" id="taaEnable"> Enable TAA
      </label>
    </div>
    <div class="controlElement">
      <label>TAA Quality:
        <input type="range" id="taaQuality" min="0" max="10" step="1" value="10">
      </label>
    </div>

    <div class="controlElement">
      <label>Global Color (Hue):
        <input type="range" id="globalColor" min="0" max="360" step=".01" value="200">
      </label>
    </div>

    <!-- Glow Points Settings Module -->
    <div class="moduleHeader" data-target="glowPointsSettings" id="glowPointsHeader" style="background: #2b2b2b;">
      <span>Glow Points Settings</span>
    </div>
    <div id="glowPointsSettings" class="moduleContent" style="display: none;">
      <div class="controlElement">
        <label>Stop 1 Position
          <input type="range" id="glowStop0Pos" min="0" max="1" step="0.01" value="0">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 1 Alpha
          <input type="range" id="glowStop0Alpha" min="0" max="2" step="0.01" value="1">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 2 Position
          <input type="range" id="glowStop1Pos" min="0" max="1" step="0.01" value="0.15">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 2 Alpha
          <input type="range" id="glowStop1Alpha" min="0" max="2" step="0.01" value="1">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 3 Position
          <input type="range" id="glowStop2Pos" min="0" max="1" step="0.01" value="0.25">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 3 Alpha
          <input type="range" id="glowStop2Alpha" min="0" max="2" step="0.01" value="0.4">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 4 Position
          <input type="range" id="glowStop3Pos" min="0" max="1" step="0.01" value="1">
        </label>
      </div>
      <div class="controlElement">
        <label>Stop 4 Alpha
          <input type="range" id="glowStop3Alpha" min="0" max="2" step="0.01" value="0">
        </label>
      </div>
    </div>
    <!-- End Glow Points Settings -->

    <!-- Slideshow Controls Section -->
    <div id="slideshowControls">
      <button id="startSlideshow">SLIDESHOW</button>
      <div id="slideshowOptions">
        <label for="slideshowRandom">
          <input type="checkbox" id="slideshowRandom"> Random
        </label>
        <label for="slideshowInterval">
          Interval: <input type="number" id="slideshowInterval" min="1" max="30" value="5" style="width:40px;"> min
        </label>
      </div>
      <div id="slideshowInstructions" style="font-size:10px; text-align:center; margin-top:4px;">
        Click Anywhere to Disable
      </div>
    </div>

    <!-- Favorite Settings Section -->
    <div id="favoriteSettingsSection">
      <button id="saveFavorite">Save Favorite</button>
      <button id="toggleFavoriteList">FAVORITES ...</button>
      <button id="exportFavorites">BACKUP</button>
      <span id="exportStatusText" style="font-size:6.5px; margin-left:2px;"></span>
      <button id="importFavorites">IMPORT</button>
      <span id="importStatusText" style="font-size:6.5px; margin-left:2px;"></span>
      <input type="file" id="importFavoritesInput" accept="application/json" style="display:none;">
      <div id="favoriteListContainer">
        <ul id="favoriteList"></ul>
      </div>
    </div>
  </div> <!-- Correctly closing #globalSettings -->

  <!-- Sound Module Panel -->
  <div class="moduleHeader" data-target="soundModule" style="background: #2b2b2b;">Sound Module</div>
  <div id="soundModule" class="moduleContent">
    <div class="controlElement">
      <label>
        <input type="checkbox" id="soundEnable" checked> Enable Sound Input
      </label>
    </div>
    <div class="controlElement">
      <label>Sensitivity:
        <input type="range" id="soundSensitivity" min="0.0" max="0.6" step="0.001" value="0.0">
      </label>
    </div>
    <div class="controlElement">
      <label>
        <input type="checkbox" id="soundEffectEmissive" checked> Emissive Intensity Modulation
      </label>
    </div>
    <div class="controlElement">
      <label>
        <input type="checkbox" id="soundEffectScale" checked> Disk Scale Expansion
      </label>
    </div>
    <div class="controlElement">
      <label>Expansion Factor:
        <input type="range" id="soundExpansionFactor" min="0" max="15" step="0.001" value="2">
      </label>
    </div>
    <div class="controlElement">
      <label>
        <input type="checkbox" id="soundJitterEnable" checked> Jitter (*enables Rossler)
      </label>
    </div>
    <div class="controlElement">
      <label>Jitter Low Range (50 - 100):
        <input type="range" id="soundJitterLow" min="50" max="160" step="0.0001" value="100">
      </label>
    </div>
    <div class="controlElement">
      <label>Jitter High Range (161 - 200):
        <input type="range" id="soundJitterHigh" min="161" max="260" step="0.001" value="">
      </label>
    </div>
    <div class="controlElement">
      <label>Jitter Modulation Strength (0 - 2.0):
        <input type="range" id="soundJitterModStrength" min="0" max="1.7" step="0.0001" value=".5">
      </label>
    </div>
    <div class="controlElement" id="soundStatus" style="font-size:11px; text-align:center;">
      Click "Start Audio" to begin.
    </div>
    <div class="controlElement" style="text-align:center;">
      <button id="startAudio" style="padding:4px 8px; font-size:11px;">Start Audio</button>
    </div>
  </div>

  <!-- Equation Modules Container -->
  <div id="eqModules">
    <div id="pathsCategory">
      <div class="moduleHeader" data-target="pathsContent">Paths</div>
      <div id="pathsContent" class="moduleContent"></div>
    </div>
    <div id="distortionsCategory">
      <div class="moduleHeader" data-target="distortionsContent">Distortions</div>
      <div id="distortionsContent" class="moduleContent"></div>
    </div>
    <div id="noisesCategory">
      <div class="moduleHeader" data-target="noisesContent">Noises</div>
      <div id="noisesContent" class="moduleContent"></div>
    </div>
  </div>
</div> <!-- Closing #controlPanel -->

<div id="thumbnailCaptureMessage" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(50, 50, 50, 0.9); color: #fff; padding: 10px 20px; border-radius: 8px; z-index: 1000; font-size: 14px;">
  Grabbing thumbnails for your old favorites...
</div>

<!-- Slideshow Exit Confirmation Modal -->
<div id="slideshowExitModal">
  <div>Exit Slideshow?</div>
  <button id="exitSlideshowYes">EXIT</button>
  <div id="countdownTimer">Closing in 4s</div>
</div>


<!-- About Modal (Added) -->
<div id="aboutModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(50, 50, 50, 0.9); color: #fff; padding: 20px; border-radius: 8px; z-index: 1000; text-align: center; width: 300px;">
  <img id="pulseIcon" src="./assets/icon.ico" alt="PuLsE Icon" style="width: 64px; height: 64px; margin-bottom: 15px; border-radius: 8px;">
  <p style="margin: 10px 0; font-size: 16px;">PuLsE 11.3.1</p>
  <p style="margin: 5px 0; font-size: 12px;">Copyright Patrick G. Leamy<br>Boxed Pandora on X.com @pgleamy</p>
  <p style="margin: 10px 0; font-size: 12px;">High performance customized music visualization<br>Enjoy the PuLsE vibe</p>
  <div style="display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
    <button id="closeAbout" style="padding: 5px 15px; background: #777; color: #fff; border: none; border-radius: 4px; cursor: pointer;">OK</button>
    <a href="https://www.paypal.com/donate/?hosted_button_id=KL9MTW9S89GFJ" target="_blank" rel="noopener noreferrer" title="Donate $5 to support PuLsE development" style="padding: 5px 15px; background: #777; color: #fff; border: none; border-radius: 4px; text-decoration: none; cursor: pointer;">Donate $5</a>
  </div>
</div>




  <!-- Three.js r154 Code -->
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
  import { TAARenderPass } from "three/addons/postprocessing/TAARenderPass.js";



    // Global variable for global speed (used by some equations)
    let GLOBAL_SPEED = 1.0;
    // Global frequency data is stored on the SoundModule instance.
    window.soundMod = null;
    window.soundModBass = 0;
    window.soundModMid = 0;
    window.soundModHigh = 0;

    /**************** Utility Functions ****************/
    function hexToRgb(hex) {
      const bigint = parseInt(hex.replace('#',''), 16);
      return { r: ((bigint >> 16) & 255)/255, g: ((bigint >> 8) & 255)/255, b: (bigint & 255)/255 };
    }
    function hslToRgb(h, s, l) {
      h /= 360;
      let r, g, b;
      if(s === 0){
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if(t < 0) t += 1;
          if(t > 1) t -= 1;
          if(t < 1/6) return p + (q - p) * 6 * t;
          if(t < 1/2) return q;
          if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l - q;
        r = hue2rgb(p, q, h+1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h-1/3);
      }
      return { r, g, b };
    }

    /**************** Global Constant ****************/
    const DEFAULT_POINT_COUNT = 30000;





    /**************** Equation Classes ****************/
class EquationBase {
    constructor() {
        this.enabled = true;
        this.speed = 1.0;
        this.baseColor = "#ffffff";
        this.pointCount = DEFAULT_POINT_COUNT;
        this.isStateful = false;
    }

    getStateDefinition() { return []; }
    initializeState(renderer, pointCount) {}
    updateState(renderer, deltaTime, time) {}
    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `vec3 compute_${this.id}(${indexVar}, ${totalPointsVar}, ${timeVar}) { return vec3(0.0); }`;
    }
    getContributionFromState(indexVar, totalPointsVar, timeVar, stateSamplers) {
        return `vec3 compute_${this.id}(${indexVar}, ${totalPointsVar}, ${timeVar}) { return vec3(0.0); }`;
    }
    getStateSamplerNames() { return []; }
    getUniforms() {
        return {
            speed: this.speed // Default uniform, can be overridden by subclasses
        };
    }
    getContribution(index, totalPoints, time) {
        return new THREE.Vector3(0, 0, 0);
    }
    setParameters(params) {
        if (params.speed !== undefined) this.speed = params.speed;
        if (params.baseColor !== undefined) this.baseColor = params.baseColor;
    }
    setPointCount(n) { this.pointCount = n; }
    calculateColorPalette(baseHex) { return [baseHex]; }
    serializeState() { return {}; }
    deserializeState(state) {}
}






class LissajousEquation extends EquationBase {
    constructor() {
        super();
        this.id = "lissajous"; // Unique identifier for shader integration
        this.A = 50;
        this.B = 50;
        this.a = 3;
        this.b = 2;
        this.delta = Math.PI / 2;
        this.t = 0;
     	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_lissajous(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * lissajous_speed * globalSpeed;
                float tVal = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float x = lissajous_A * sin(lissajous_a * tVal + lissajous_delta);
                float y = lissajous_B * sin(lissajous_b * tVal);
                float z = 20.0 * cos(tVal);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            A: this.A,
            B: this.B,
            a: this.a,
            b: this.b,
            delta: this.delta,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index / totalPoints) * Math.PI * 2;
        const x = this.A * Math.sin(this.a * tVal + this.delta);
        const y = this.B * Math.sin(this.b * tVal);
        const z = 20 * Math.cos(tVal);
        return new THREE.Vector3(x, y, z);
    }
}







class RoseCurveEquation extends EquationBase {
    constructor() {
        super();
        this.id = "roseCurve";  // Unique identifier for shader integration
        this.A = 70;
        this.k = 4;
        this.t = 0;
        this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_${this.id}(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * ${this.id}_speed * globalSpeed;
                float theta = (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float r = ${this.id}_A * cos(${this.id}_k * theta + localT);
                float x = r * cos(theta);
                float y = r * sin(theta);
                float z = 10.0 * sin(3.0 * theta + localT);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            A: this.A,
            k: this.k,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const theta = (index / totalPoints) * Math.PI * 2;
        const r = this.A * Math.cos(this.k * theta + this.t);
        return new THREE.Vector3(
            r * Math.cos(theta),
            r * Math.sin(theta),
            10 * Math.sin(3 * theta + this.t)
        );
    }
}









class SpiralEquation extends EquationBase {
    constructor() {
        super();
        this.id = "spiral";  // Unique identifier for shader integration
        this.a = 5;
        this.b = 4;
        this.t = 0;
        this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_spiral(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * spiral_speed * globalSpeed;
                float theta = (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 8.0;
                float r = spiral_a + spiral_b * theta;
                float x = r * cos(theta + localT);
                float y = r * sin(theta + localT);
                float z = 10.0 * sin(theta / 3.0 + localT);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            a: this.a,
            b: this.b,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const theta = (index / totalPoints) * Math.PI * 8;
        const r = this.a + this.b * theta;
        return new THREE.Vector3(
            r * Math.cos(theta + this.t),
            r * Math.sin(theta + this.t),
            10 * Math.sin(theta / 3 + this.t)
        );
    }
}










class FourierSeriesEquation extends EquationBase {
    constructor() {
        super();
        this.id = "fourierSeries";
        this.maxTerms = 20;
        this.numTerms = 10;
        this.baseAmp = 20;
        this.phases = [];
        this.A = []; // Initialize A array
        for (let n = 0; n < this.maxTerms; n++) {
            this.phases.push(Math.random() * Math.PI * 2);
            if (n < this.numTerms) {
                this.A.push(this.baseAmp / (n + 1)); // Initialize amplitudes
            }
        }
        this.t = 0;
        this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_fourierSeries(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * fourierSeries_speed * globalSpeed;
                float tVal = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float x = 0.0;
                float y = 0.0;
                for (int n = 1; n <= int(fourierSeries_numTerms); n++) {
                    float A_n = fourierSeries_baseAmp / float(n);
                    float phase = fourierSeries_phases[n - 1];
                    x += A_n * cos(float(n) * tVal + phase);
                    y += A_n * sin(float(n) * tVal + phase);
                }
                float z = 10.0 * sin(2.0 * tVal);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            numTerms: this.numTerms,
            baseAmp: this.baseAmp,
            speed: this.speed,
            phases: this.phases
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index / totalPoints) * Math.PI * 2;
        let x = 0, y = 0;
        for (let n = 1; n <= this.numTerms; n++) {
            const A_n = this.baseAmp / n; // Compute amplitude on the fly
            x += A_n * Math.cos(n * tVal + this.phases[n - 1]);
            y += A_n * Math.sin(n * tVal + this.phases[n - 1]);
        }
        return new THREE.Vector3(x, y, 10 * Math.sin(2 * tVal));
    }
}











class SHMEquation extends EquationBase {
    constructor() {
        super();
        this.id = "shm";  // Unique identifier for shader integration
        this.A = 50;
        this.omega = 2;
        this.phi = 0;
        this.t = 0;
        this.globalSpeed = window.GLOBAL_SPEED;        
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_shm(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * shm_speed * globalSpeed;
                float tVal = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float x = shm_A * cos(shm_omega * tVal + shm_phi);
                float y = shm_A * sin(shm_omega * tVal + shm_phi);
                float z = 10.0 * sin(shm_omega * tVal);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            A: this.A,
            omega: this.omega,
            phi: this.phi,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index / totalPoints) * Math.PI * 2;
        return new THREE.Vector3(
            this.A * Math.cos(this.omega * tVal + this.phi),
            this.A * Math.sin(this.omega * tVal + this.phi),
            10 * Math.sin(this.omega * tVal)
        );
    }
}












class FluidFlowEquation extends EquationBase {
    constructor() {
        super();
        this.id = "fluidFlow";
        this.noiseScale = 0.05;
        this.flowSpeed = 50;
        this.timeScale = 0.5;
        this.turbulence = 1.0;
        this.speed = 1.0;
        this.enabled = false;
    }

    serializeState() {
        return {
            noiseScale: this.noiseScale,
            timeScale: this.timeScale,
            flowSpeed: this.flowSpeed,
            turbulence: this.turbulence,
            speed: this.speed,
            enabled: this.enabled
        };
    }

    deserializeState(state) {
        if (state) {
            this.noiseScale = state.noiseScale !== undefined ? state.noiseScale : this.noiseScale;
            this.timeScale = state.timeScale !== undefined ? state.timeScale : this.timeScale;
            this.flowSpeed = state.flowSpeed !== undefined ? state.flowSpeed : this.flowSpeed;
            this.turbulence = state.turbulence !== undefined ? state.turbulence : this.turbulence;
            this.speed = state.speed !== undefined ? state.speed : this.speed;
            this.enabled = state.enabled !== undefined ? state.enabled : this.enabled;
        }
    }

    getPerlinNoiseSnippet() {
        return `
            // Hash function for pseudo-random gradients
            vec3 hash(vec3 p) {
                p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
                        dot(p, vec3(269.5, 183.3, 246.1)),
                        dot(p, vec3(113.5, 271.9, 124.6)));
                return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
            }

            // Improved Perlin noise function
            float perlin(vec3 p) {
                vec3 i = floor(p);
                vec3 f = fract(p);
                vec3 u = f * f * (3.0 - 2.0 * f); // Smoothstep
                
                // Compute gradients at cube corners
                vec3 g000 = hash(i + vec3(0.0, 0.0, 0.0));
                vec3 g100 = hash(i + vec3(1.0, 0.0, 0.0));
                vec3 g010 = hash(i + vec3(0.0, 1.0, 0.0));
                vec3 g110 = hash(i + vec3(1.0, 1.0, 0.0));
                vec3 g001 = hash(i + vec3(0.0, 0.0, 1.0));
                vec3 g101 = hash(i + vec3(1.0, 0.0, 1.0));
                vec3 g011 = hash(i + vec3(0.0, 1.0, 1.0));
                vec3 g111 = hash(i + vec3(1.0, 1.0, 1.0));

                // Dot products with distance vectors
                float n000 = dot(g000, f);
                float n100 = dot(g100, f - vec3(1.0, 0.0, 0.0));
                float n010 = dot(g010, f - vec3(0.0, 1.0, 0.0));
                float n110 = dot(g110, f - vec3(1.0, 1.0, 0.0));
                float n001 = dot(g001, f - vec3(0.0, 0.0, 1.0));
                float n101 = dot(g101, f - vec3(1.0, 0.0, 1.0));
                float n011 = dot(g011, f - vec3(0.0, 1.0, 1.0));
                float n111 = dot(g111, f - vec3(1.0, 1.0, 1.0));

                // Interpolate along each axis
                float nx00 = mix(n000, n100, u.x);
                float nx10 = mix(n010, n110, u.x);
                float nx01 = mix(n001, n101, u.x);
                float nx11 = mix(n011, n111, u.x);
                float nxy0 = mix(nx00, nx10, u.y);
                float nxy1 = mix(nx01, nx11, u.y);
                float n = mix(nxy0, nxy1, u.z);

                return 0.5 + 0.5 * n; // Normalize to [0, 1]
            }
        `;
    }

    getCurlNoiseSnippet() {
        return `
            vec3 curlNoise(vec3 p, float t) {
                float eps = 0.01;
                float n1, n2;
                vec3 curl;
                
                // X component
                n1 = perlin(vec3(p.x, p.y, p.z + eps) + t);
                n2 = perlin(vec3(p.x, p.y, p.z - eps) + t);
                curl.x = (n1 - n2) / (2.0 * eps);
                n1 = perlin(vec3(p.x, p.y + eps, p.z) + t);
                n2 = perlin(vec3(p.x, p.y - eps, p.z) + t);
                curl.x -= (n1 - n2) / (2.0 * eps);

                // Y component
                n1 = perlin(vec3(p.x, p.z + eps, p.y) + t);
                n2 = perlin(vec3(p.x, p.z - eps, p.y) + t);
                curl.y = (n1 - n2) / (2.0 * eps);
                n1 = perlin(vec3(p.x + eps, p.z, p.y) + t);
                n2 = perlin(vec3(p.x - eps, p.z, p.y) + t);
                curl.y -= (n1 - n2) / (2.0 * eps);

                // Z component
                n1 = perlin(vec3(p.y + eps, p.z, p.x) + t);
                n2 = perlin(vec3(p.y - eps, p.z, p.x) + t);
                curl.z = (n1 - n2) / (2.0 * eps);
                n1 = perlin(vec3(p.y, p.z + eps, p.x) + t);
                n2 = perlin(vec3(p.y, p.z - eps, p.x) + t);
                curl.z -= (n1 - n2) / (2.0 * eps);

                // Smooth and normalize displacement
                float len = length(curl);
                return len > 0.0 ? normalize(curl) * fluidFlow_turbulence * smoothstep(0.0, 1.0, len) : vec3(0.0);
            }
        `;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            ${this.getPerlinNoiseSnippet()}
            ${this.getCurlNoiseSnippet()}
            vec3 compute_fluidFlow(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float t = ${timeVar} * fluidFlow_speed * fluidFlow_timeScale * globalSpeed * 0.1;
                float gridSize = sqrt(${totalPointsVar});
                float i = floor(${indexVar} / gridSize);
                float j = mod(${indexVar}, gridSize);
                vec3 basePos = vec3(i - gridSize / 2.0, j - gridSize / 2.0, 0.0);
                vec3 fieldPos = basePos * fluidFlow_noiseScale + vec3(t * 0.5, t * 0.7, t);
                vec3 displacement = curlNoise(fieldPos, t);
                return basePos + displacement * fluidFlow_flowSpeed;
            }
        `;
    }

    getUniforms() {
        return {
            noiseScale: this.noiseScale,
            flowSpeed: this.flowSpeed,
            timeScale: this.timeScale,
            turbulence: this.turbulence,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        const t = time * this.speed * this.timeScale * 0.1;
        const gridSize = Math.sqrt(totalPoints);
        const i = Math.floor(index / gridSize);
        const j = index % gridSize;
        const basePos = new THREE.Vector3(i - gridSize / 2, j - gridSize / 2, 0);
        // Simplified CPU approximation (not exact match to shader)
        const fieldPos = basePos.clone().multiplyScalar(this.noiseScale).add(
            new THREE.Vector3(t * 0.5, t * 0.7, t)
        );
        const displacement = new THREE.Vector3(
            Math.sin(fieldPos.x * 127.1 + fieldPos.z * 74.7) - Math.cos(fieldPos.y * 311.7),
            Math.sin(fieldPos.y * 269.5) - Math.cos(fieldPos.z * 183.3 + fieldPos.x * 246.1),
            Math.sin(fieldPos.z * 113.5 + fieldPos.y * 271.9) - Math.cos(fieldPos.x * 124.6)
        );
        const length = displacement.length();
        if (length > 0) {
            displacement.normalize().multiplyScalar(this.turbulence * Math.min(1, length));
        } else {
            displacement.set(0, 0, 0);
        }
        return basePos.add(displacement.multiplyScalar(this.flowSpeed));
    }
}












class ReactionDiffusionEquation extends EquationBase {
    constructor() {
        super();
        this.id = "reactionDiffusion";  // Unique identifier for shader integration
        this.gridSize = 50;
        this.Du = 0.16;
        this.Dv = 0.08;
        this.F = 0.035;
        this.k = 0.065;
        this.isStateful = true;         // Indicates stateful behavior
        this.uTexture = null;           // Texture for u grid
        this.vTexture = null;           // Texture for v grid
        this.tempUTexture = null;       // Temporary texture for ping-pong
        this.tempVTexture = null;       // Temporary texture for ping-pong
        this.initialized = false;       // Tracks initialization status
        this.globalSpeed = window.GLOBAL_SPEED;
    }

    // Initialize state textures



initializeState(renderer) {
        const size = this.gridSize;
        const uData = new Float32Array(size * size * 4);
        const vData = new Float32Array(size * size * 4);

        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const idx = (i * size + j) * 4;
                uData[idx] = 1.0;    // R
                uData[idx + 1] = 0.0; // G (unused)
                uData[idx + 2] = 0.0; // B (unused)
                uData[idx + 3] = 1.0; // A
                vData[idx] = 0.0;    // R
                vData[idx + 1] = 0.0; // G (unused)
                vData[idx + 2] = 0.0; // B (unused)
                vData[idx + 3] = 1.0; // A
            }
        }
        const mid = Math.floor(size / 2);
        const midIdx = (mid * size + mid) * 4;
        uData[midIdx] = 0.5;    // Center u = 0.5
        vData[midIdx] = 0.25;   // Center v = 0.25

        const textureOptions = {
            format: THREE.RGBAFormat, // Already correct
            type: THREE.FloatType,
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter
        };
        this.uTexture = new THREE.WebGLRenderTarget(size, size, textureOptions);
        this.vTexture = new THREE.WebGLRenderTarget(size, size, textureOptions);
        this.tempUTexture = new THREE.WebGLRenderTarget(size, size, textureOptions);
        this.tempVTexture = new THREE.WebGLRenderTarget(size, size, textureOptions);

        const uDataTexture = new THREE.DataTexture(uData, size, size, THREE.RGBAFormat, THREE.FloatType);
        const vDataTexture = new THREE.DataTexture(vData, size, size, THREE.RGBAFormat, THREE.FloatType);
        uDataTexture.needsUpdate = true;
        vDataTexture.needsUpdate = true;
        renderer.copyTextureToTexture({ x: 0, y: 0 }, uDataTexture, this.uTexture);
        renderer.copyTextureToTexture({ x: 0, y: 0 }, vDataTexture, this.vTexture);
        this.initialized = true;
    }



    // Update state textures each frame
    updateState(renderer, deltaTime, time) {
        if (!this.initialized) return;

        const updateMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: this.uTexture.texture },
                vTexture: { value: this.vTexture.texture },
                Du: { value: this.Du },
                Dv: { value: this.Dv },
                F: { value: this.F },
                k: { value: this.k },
                dt: { value: deltaTime * this.speed * globalSpeed},
                gridSize: { value: this.gridSize }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform sampler2D vTexture;
                uniform float Du;
                uniform float Dv;
                uniform float F;
                uniform float k;
                uniform float dt;
                uniform float gridSize;
                varying vec2 vUv;

                void main() {
                    vec2 texel = vec2(1.0 / gridSize, 1.0 / gridSize);
                    vec4 uCenter = texture2D(uTexture, vUv);
                    vec4 vCenter = texture2D(vTexture, vUv);
                    vec4 uLeft = texture2D(uTexture, vUv + vec2(-texel.x, 0.0));
                    vec4 uRight = texture2D(uTexture, vUv + vec2(texel.x, 0.0));
                    vec4 uUp = texture2D(uTexture, vUv + vec2(0.0, texel.y));
                    vec4 uDown = texture2D(uTexture, vUv + vec2(0.0, -texel.y));
                    vec4 vLeft = texture2D(vTexture, vUv + vec2(-texel.x, 0.0));
                    vec4 vRight = texture2D(vTexture, vUv + vec2(texel.x, 0.0));
                    vec4 vUp = texture2D(vTexture, vUv + vec2(0.0, texel.y));
                    vec4 vDown = texture2D(vTexture, vUv + vec2(0.0, -texel.y));

                    float lapU = (uLeft.r + uRight.r + uUp.r + uDown.r - 4.0 * uCenter.r);
                    float lapV = (vLeft.r + vRight.r + vUp.r + vDown.r - 4.0 * vCenter.r);

                    float du = Du * lapU - uCenter.r * vCenter.r * vCenter.r + F * (1.0 - uCenter.r);
                    float dv = Dv * lapV + uCenter.r * vCenter.r * vCenter.r - (F + k) * vCenter.r;

                    float newU = uCenter.r + du * dt;
                    float newV = vCenter.r + dv * dt;

                    gl_FragColor = vec4(newU, newV, 0.0, 1.0);
                }
            `
        });

        // Ping-pong rendering to temporary textures
        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), updateMaterial);
        renderer.setRenderTarget(this.tempUTexture);
        renderer.render(quad, new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1));
        renderer.setRenderTarget(this.tempVTexture);
        renderer.render(quad, new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1));
        renderer.setRenderTarget(null);

        // Swap textures for next frame
        [this.uTexture, this.tempUTexture] = [this.tempUTexture, this.uTexture];
        [this.vTexture, this.tempVTexture] = [this.tempVTexture, this.vTexture];

        // Clean up resources
        quad.geometry.dispose();
        updateMaterial.dispose();
    }

    // Shader snippet for position computation
    getContributionFromState(indexVar, totalPointsVar, timeVar, stateSamplers) {
        return `
            vec3 compute_reactionDiffusion(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float gridSize = ${this.gridSize}.0;
                float i = floor(${indexVar} / gridSize);
                float j = mod(${indexVar}, gridSize);
                vec2 uv = vec2(j / gridSize, i / gridSize);
                float uVal = texture2D(${stateSamplers[0]}, uv).r;
                float x = i - gridSize / 2.0;
                float y = j - gridSize / 2.0;
                float z = uVal * 50.0;
                return vec3(x, y, z);
            }
        `;
    }

    // Define state sampler name
    getStateSamplerNames() {
        return ['uTexture_reactionDiffusion'];
    }

    // Serialization (limited to parameters since textures aren't serializable)
    serializeState() {
        return { Du: this.Du, Dv: this.Dv, F: this.F, k: this.k, gridSize: this.gridSize };
    }

    deserializeState(state) {
        if (state) {
            this.Du = state.Du || this.Du;
            this.Dv = state.Dv || this.Dv;
            this.F = state.F || this.F;
            this.k = state.k || this.k;
            this.gridSize = state.gridSize || this.gridSize;
            this.initialized = false; // Requires re-initialization
        }
    }
}












    class SimplexNoise {
      constructor(seed = Math.random()){
        this.seed = seed;        
      }
      noise(x,y,z){
        return (Math.sin(x*12.9898 + y*78.233 + z*37.719 + this.seed*43758.5453)) % 1;
      }
    }









class NoiseEquation extends EquationBase {
    constructor() {
        super();
        this.id = "noiseEq";           // Unique identifier for shader integration
        this.scaleFactor = 100;
        this.t = 0;
        this.simplex = new SimplexNoise();  // Retain for CPU compatibility
        this.setPointCount(this.pointCount);
        this.globalSpeed = window.GLOBAL_SPEED;
    }

getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_noiseEq(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * noiseEq_speed * globalSpeed;
                float tVal = localT + ${indexVar} * 0.01;
                float n = noise(tVal, tVal, tVal, noiseEq_seed);
                float x = noiseEq_scaleFactor * n * cos(tVal);
                float y = noiseEq_scaleFactor * n * sin(tVal);
                float z = 50.0 * n;
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            scaleFactor: this.scaleFactor,
            speed: this.speed,
            seed: this.simplex.seed  // Pass the seed from SimplexNoise
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + index * 0.01;
        const n = this.simplex.noise(tVal, tVal, tVal);
        return new THREE.Vector3(
            this.scaleFactor * n * Math.cos(tVal),
            this.scaleFactor * n * Math.sin(tVal),
            50 * n
        );
    }

    update(deltaTime, time) { }
}










class FractalNoiseEquation extends EquationBase {
    constructor() {
        super();
        this.id = "fractalNoise";       // Unique identifier for shader integration
        this.scaleFactor = 100;
        this.octaves = 4;
        this.persistence = 0.5;
        this.simplex = new SimplexNoise();  // Retained for CPU compatibility
        this.t = 0;
        this.globalSpeed = window.GLOBAL_SPEED;
    }

getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_fractalNoise(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * fractalNoise_speed * globalSpeed;
                float tVal = localT + ${indexVar} * 0.01;
                float noiseValue = 0.0;
                float amplitude = 1.0;
                float frequency = 1.0;
                float maxAmplitude = 0.0;
                for (int i = 0; i < ${this.octaves}; i++) {
                    noiseValue += amplitude * noise(tVal * frequency, tVal * frequency, tVal * frequency, fractalNoise_seed);
                    maxAmplitude += amplitude;
                    amplitude *= fractalNoise_persistence;
                    frequency *= 2.0;
                }
                noiseValue /= maxAmplitude;
                float x = fractalNoise_scaleFactor * noiseValue * cos(tVal);
                float y = fractalNoise_scaleFactor * noiseValue * sin(tVal);
                float z = 50.0 * noiseValue;
                return vec3(x, y, z);
            }
        `;
    }
    getUniforms() {
        return {
            scaleFactor: this.scaleFactor,
            octaves: this.octaves,
            persistence: this.persistence,
            speed: this.speed,
            seed: this.simplex.seed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + index * 0.01;
        let noiseValue = 0;
        let amplitude = 1.0;
        let frequency = 1.0;
        let maxAmplitude = 0;
        for (let i = 0; i < this.octaves; i++) {
            noiseValue += amplitude * this.simplex.noise(tVal * frequency, tVal * frequency, tVal * frequency);
            maxAmplitude += amplitude;
            amplitude *= this.persistence;
            frequency *= 2.0;
        }
        noiseValue /= maxAmplitude;
        return new THREE.Vector3(
            this.scaleFactor * noiseValue * Math.cos(tVal),
            this.scaleFactor * noiseValue * Math.sin(tVal),
            50 * noiseValue
        );
    }

    update(deltaTime, time) { }
}












class RidgedNoiseEquation extends EquationBase {
    constructor() {
        super();
        this.id = "ridgedNoise";        // Unique identifier for shader integration
        this.scaleFactor = 100;
        this.simplex = new SimplexNoise();  // Retained for CPU compatibility
        this.t = 0;
        this.globalSpeed = window.GLOBAL_SPEED;
    }

getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_ridgedNoise(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * ridgedNoise_speed * globalSpeed;
                float tVal = localT + ${indexVar} * 0.01;
                float n = noise(tVal, tVal, tVal, ridgedNoise_seed);
                float ridged = 1.0 - abs(n - 0.5) * 2.0; // Maps [0, 1] to ridged noise
                float x = ridgedNoise_scaleFactor * ridged * cos(tVal);
                float y = ridgedNoise_scaleFactor * ridged * sin(tVal);
                float z = 50.0 * ridged;
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            scaleFactor: this.scaleFactor,
            speed: this.speed,
            seed: this.simplex.seed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + index * 0.01;
        let n = this.simplex.noise(tVal, tVal, tVal);
        const ridged = 1.0 - Math.abs(n);
        return new THREE.Vector3(
            this.scaleFactor * ridged * Math.cos(tVal),
            this.scaleFactor * ridged * Math.sin(tVal),
            50 * ridged
        );
    }

    update(deltaTime, time) { }
}










class VoronoiNoiseEquation extends EquationBase {
    constructor() {
        super();
        this.id = "voronoiNoise";       // Unique identifier for shader integration
        this.scaleFactor = 100;
        this.cellSize = 0.05;           // Controls cell density
        this.t = 0;
        this.seedCount = 20;
        this.globalSpeed = window.GLOBAL_SPEED;
        this.seeds = [];
        for (let i = 0; i < this.seedCount; i++) {
            this.seeds.push([
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ]);
        }
    }

getContributionShader(indexVar, totalPointsVar, timeVar) {
        let seedsArray = 'vec3 seeds[20] = vec3[20](';
        for (let i = 0; i < this.seedCount; i++) {
            seedsArray += `vec3(${this.seeds[i][0]}, ${this.seeds[i][1]}, ${this.seeds[i][2]})`;
            if (i < this.seedCount - 1) seedsArray += ', ';
        }
        seedsArray += ');';

        return `
            ${seedsArray}

            vec3 compute_voronoiNoise(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * voronoiNoise_speed * globalSpeed;
		float tVal = localT + ${indexVar} * 0.01;
                float x = tVal * voronoiNoise_cellSize;
                float y = tVal * voronoiNoise_cellSize;
                float z = localT * voronoiNoise_cellSize;

                float minDist = 1e10;  // Large initial value
                for (int i = 0; i < ${this.seedCount}; i++) {
                    float sx = seeds[i].x + sin(localT * 0.1 + float(i)) * 0.1;
                    float sy = seeds[i].y + cos(localT * 0.1 + float(i)) * 0.1;
                    float sz = seeds[i].z;
                    float dx = x - sx;
                    float dy = y - sy;
                    float dz = z - sz;
                    float dist = sqrt(dx * dx + dy * dy + dz * dz);
                    minDist = min(minDist, dist);
                }

                float n = min(minDist * 5.0, 1.0); // Normalize and clamp
                float cx = voronoiNoise_scaleFactor * n * cos(tVal);
                float cy = voronoiNoise_scaleFactor * n * sin(tVal);
                float cz = 50.0 * n;
                return vec3(cx, cy, cz);
            }
        `;
    }
    getUniforms() {
        return {
            scaleFactor: this.scaleFactor,
            cellSize: this.cellSize,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
	const tVal = this.t + index * 0.01;
        const x = tVal * this.cellSize;
        const y = tVal * this.cellSize;
        const z = this.t * this.cellSize;
        let minDist = Infinity;
        for (let i = 0; i < this.seedCount; i++) {
            const sx = this.seeds[i][0] + Math.sin(this.t * 0.1 + i) * 0.1;
            const sy = this.seeds[i][1] + Math.cos(this.t * 0.1 + i) * 0.1;
            const sz = this.seeds[i][2];
            const dist = Math.sqrt(
                (x - sx) * (x - sx) +
                (y - sy) * (y - sy) +
                (z - sz) * (z - sz)
            );
            minDist = Math.min(minDist, dist);
        }
        const n = Math.min(minDist * 5, 1); // Normalize and clamp
        return new THREE.Vector3(
            this.scaleFactor * n * Math.cos(tVal),
            this.scaleFactor * n * Math.sin(tVal),
            50 * n
        );
    }

    update(deltaTime, time) {}
}










class SineDistortionEquation extends EquationBase {
    constructor() {
        super();
        this.id = "sineDistortion";     // Unique identifier for shader integration
        this.offsetX = 0;
        this.offsetY = -100;
        this.kDiv = 8;
        this.kSub = 12;
        this.scaleFactor = 0.7;
        this.xAmplitude = 20;
        this.yAmplitude = 20;
        this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_sineDistortion(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float dimension = floor(sqrt(${totalPointsVar}));
                float row = floor(${indexVar} / dimension);
                float col = mod(${indexVar}, dimension);
                float px = col - dimension / 2.0 + sineDistortion_offsetX;
                float py = row - dimension / 2.0 + sineDistortion_offsetY;
                float pz = 0.0;
                float tVal = ${timeVar} * sineDistortion_speed * globalSpeed;
                float k = px / sineDistortion_kDiv - sineDistortion_kSub;
                float e = py / sineDistortion_kDiv - sineDistortion_kSub;
                px += sin(k + tVal) * sineDistortion_xAmplitude;
                py += cos(e + tVal) * sineDistortion_yAmplitude;
                px *= sineDistortion_scaleFactor;
                py *= sineDistortion_scaleFactor;
                return vec3(px, py, pz);
            }
        `;
    }

    getUniforms() {
        return {
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            kDiv: this.kDiv,
            kSub: this.kSub,
            scaleFactor: this.scaleFactor,
            xAmplitude: this.xAmplitude,
            yAmplitude: this.yAmplitude,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2 + this.offsetX;
        let py = row - dimension/2 + this.offsetY;
        let pz = 0;
        const tVal = time * this.speed;
        const k = px / this.kDiv - this.kSub;
        const e = py / this.kDiv - this.kSub;
        px += Math.sin(k + tVal) * this.xAmplitude;
        py += Math.cos(e + tVal) * this.yAmplitude;
        px *= this.scaleFactor;
        py *= this.scaleFactor;
        return new THREE.Vector3(px, py, pz);
    }
}











class PhaseRippleEquation extends EquationBase {
    constructor() {
        super();
        this.id = "phaseRipple";        // Unique identifier for shader integration
        this.phaseFactor = 0.1;
        this.xAmplitude = 20;
        this.yAmplitude = 20;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_phaseRipple(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float dimension = floor(sqrt(${totalPointsVar}));
                float row = floor(${indexVar} / dimension);
                float col = mod(${indexVar}, dimension);
                float px = col - dimension / 2.0;
                float py = row - dimension / 2.0;
                float pz = 0.0;
                float tVal = ${timeVar} * phaseRipple_speed * globalSpeed;
                float phase = sin((px / 10.0) + (py / 10.0) * phaseRipple_phaseFactor + tVal);
                px += phase * phaseRipple_xAmplitude;
                py += phase * phaseRipple_yAmplitude;
                return vec3(px, py, pz);
            }
        `;
    }

    getUniforms() {
        return {
            phaseFactor: this.phaseFactor,
            xAmplitude: this.xAmplitude,
            yAmplitude: this.yAmplitude,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2;
        let py = row - dimension/2;
        let pz = 0;
        const tVal = time * this.speed;
        const phase = Math.sin((px / 10) + (py / 10) * this.phaseFactor + tVal);
        px += phase * this.xAmplitude;
        py += phase * this.yAmplitude;
        return new THREE.Vector3(px, py, pz);
    }
}










class ZSineWarpEquation extends EquationBase {
    constructor() {
        super();
        this.id = "zSineWarp";         // Unique identifier for shader integration
        this.zAmplitude = 30;
        this.frequency = 0.5;
  	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_zSineWarp(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float dimension = floor(sqrt(${totalPointsVar}));
                float row = floor(${indexVar} / dimension);
                float col = mod(${indexVar}, dimension);
                float px = col - dimension / 2.0;
                float py = row - dimension / 2.0;
                float tVal = ${timeVar} * zSineWarp_speed * globalSpeed;
                float pz = sin(tVal * zSineWarp_frequency + (px * py) / 10000.0) * zSineWarp_zAmplitude;
                return vec3(px, py, pz);
            }
        `;
    }

    getUniforms() {
        return {
            zAmplitude: this.zAmplitude,
            frequency: this.frequency,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2;
        let py = row - dimension/2;
        const tVal = time * this.speed;
        const pz = Math.sin(tVal * this.frequency + (px * py) / 10000) * this.zAmplitude;
        return new THREE.Vector3(px, py, pz);
    }
}









class RadialTwistEquation extends EquationBase {
    constructor() {
        super();
        this.id = "radialTwist";        // Unique identifier for shader integration
        this.radialFactor = 0.5;
        this.twistFactor = 2;
        this.zWaveFrequency = 0.3;
        this.zWaveAmplitude = 20;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_radialTwist(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float dimension = floor(sqrt(${totalPointsVar}));
                float row = floor(${indexVar} / dimension);
                float col = mod(${indexVar}, dimension);
                float px = col - dimension / 2.0;
                float py = row - dimension / 2.0;
                float pz = 0.0;
                float tVal = ${timeVar} * radialTwist_speed * globalSpeed;

                float radius = sqrt(abs(px + py * py)); // Avoid NaN, matches CPU fix
                float angle = atan(py, px) + radialTwist_twistFactor * radius + tVal * radialTwist_radialFactor;
                float oldPx = px;
                float oldPy = py;
                px += radius * cos(angle) - oldPx;
                py += radius * sin(angle) - oldPy;
                pz += sin(radius * radialTwist_zWaveFrequency + tVal) * radialTwist_zWaveAmplitude;

                return vec3(px, py, pz);
            }
        `;
    }

    getUniforms() {
        return {
            radialFactor: this.radialFactor,
            twistFactor: this.twistFactor,
            zWaveFrequency: this.zWaveFrequency,
            zWaveAmplitude: this.zWaveAmplitude,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        const dimension = Math.floor(Math.sqrt(this.pointCount));
        const row = Math.floor(index / dimension);
        const col = index % dimension;
        let px = col - dimension/2;
        let py = row - dimension/2;
        let pz = 0;
        const tVal = time * this.speed;
        const radius = Math.sqrt(Math.abs(px + py*py)); // replaced above to avoid NaN error
        const angle = Math.atan2(py, px) + this.twistFactor * radius + tVal * this.radialFactor;
        const oldPx = px;
        const oldPy = py;
        px += radius * Math.cos(angle) - oldPx;
        py += radius * Math.sin(angle) - oldPy;
        pz += Math.sin(radius * this.zWaveFrequency + tVal) * this.zWaveAmplitude;
        return new THREE.Vector3(px, py, pz);
    }
}










class TorusEquation extends EquationBase {
    constructor() {
        super();
        this.id = "torus";         // Unique identifier for shader integration
        this.R = 50;               // Major radius
        this.r = 20;               // Minor radius
        this.t = 0;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_torus(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * torus_speed * globalSpeed;
                float u = (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float v = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float x = (torus_R + torus_r * cos(v)) * cos(u);
                float y = (torus_R + torus_r * cos(v)) * sin(u);
                float z = torus_r * sin(v);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            R: this.R,
            r: this.r,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const u = (index / totalPoints) * Math.PI * 2;
        const v = this.t + (index / totalPoints) * Math.PI * 2;
        return new THREE.Vector3(
            (this.R + this.r * Math.cos(v)) * Math.cos(u),
            (this.R + this.r * Math.cos(v)) * Math.sin(u),
            this.r * Math.sin(v)
        );
    }
}








class NoiseJitterEquation extends EquationBase {
    constructor() {
        super();
        this.id = "rossler";            // Unique identifier set to "rossler" as per original context
        this.jitterFactor = 0.0;
        this.frequency = 44000;
        this.amplitude = 2;
        this.baseJitterFactor = this.jitterFactor; // For sound modulation
        this.speed = 10;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
vec3 compute_rossler(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
    float t = mod(${timeVar} * rossler_speed * rossler_frequency, 1000.0);
    float phase = (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
    float nx = sin(t + phase) * cos(t * 0.5 + ${indexVar} * 0.01);
    float ny = cos(t + phase) * sin(t * 0.7 + ${indexVar} * 0.02);
    float nz = sin(t * 0.3 + phase) * cos(${indexVar} * 0.015);
    return vec3(
        nx * rossler_jitterFactor * rossler_amplitude,
        ny * rossler_jitterFactor * rossler_amplitude,
        nz * rossler_jitterFactor * rossler_amplitude
    );
}        `;
    }

    getUniforms() {
        return {
            jitterFactor: this.jitterFactor,
            frequency: this.frequency,
            amplitude: this.amplitude,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        const t = (time * this.speed * this.frequency) % 1000.0;
        const phase = (index / totalPoints) * Math.PI * 2;
        const nx = Math.sin(t + phase) * Math.cos(t * 0.5 + index * 0.01);
        const ny = Math.cos(t + phase) * Math.sin(t * 0.7 + index * 0.02);
        const nz = Math.sin(t * 0.3 + phase) * Math.cos(index * 0.015);
        return new THREE.Vector3(
            nx * this.jitterFactor * this.amplitude,
            ny * this.jitterFactor * this.amplitude,
            nz * this.jitterFactor * this.amplitude
        );
    }

    serializeState() {
        return {
            jitterFactor: this.jitterFactor,
            frequency: this.frequency,
            amplitude: this.amplitude,
            baseJitterFactor: this.baseJitterFactor
        };
    }

    deserializeState(state) {
        if (state) {
            this.jitterFactor = state.jitterFactor !== undefined ? state.jitterFactor : this.jitterFactor;
            this.frequency = state.frequency !== undefined ? state.frequency : this.frequency;
            this.amplitude = state.amplitude !== undefined ? state.amplitude : this.amplitude;
            this.baseJitterFactor = state.baseJitterFactor !== undefined ? state.baseJitterFactor : this.baseJitterFactor;
        }
    }
}







class EpicycloidEquation extends EquationBase {
    constructor() {
        super();
        this.id = "epicycloid";         // Unique identifier for shader integration
        this.R = 80;                    // Fixed circle radius
        this.r = 30;                    // Rolling circle radius
        this.zAmplitude = 20;           // Z-axis amplitude
        this.zFrequency = 1.0;          // Z-axis frequency
        this.t = 0;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_epicycloid(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * epicycloid_speed * globalSpeed;
                float tVal = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float x = (epicycloid_R + epicycloid_r) * cos(tVal) - epicycloid_r * cos(((epicycloid_R + epicycloid_r) / epicycloid_r) * tVal);
                float y = (epicycloid_R + epicycloid_r) * sin(tVal) - epicycloid_r * sin(((epicycloid_R + epicycloid_r) / epicycloid_r) * tVal);
                float z = epicycloid_zAmplitude * sin(epicycloid_zFrequency * tVal);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            R: this.R,
            r: this.r,
            zAmplitude: this.zAmplitude,
            zFrequency: this.zFrequency,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index / totalPoints) * Math.PI * 2;
        const x = (this.R + this.r) * Math.cos(tVal) - this.r * Math.cos(((this.R + this.r) / this.r) * tVal);
        const y = (this.R + this.r) * Math.sin(tVal) - this.r * Math.sin(((this.R + this.r) / this.r) * tVal);
        const z = this.zAmplitude * Math.sin(this.zFrequency * tVal);
        return new THREE.Vector3(x, y, z);
    }
}










class HypocycloidEquation extends EquationBase {
    constructor() {
        super();
        this.id = "hypocycloid";        // Unique identifier for shader integration
        this.R = 80;                    // Fixed circle radius
        this.r = 30;                    // Rolling circle radius
        this.zAmplitude = 20;           // Z-axis amplitude
        this.zFrequency = 1.0;          // Z-axis frequency
        this.t = 0;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_hypocycloid(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * hypocycloid_speed * globalSpeed;
                float tVal = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float x = (hypocycloid_R - hypocycloid_r) * cos(tVal) + hypocycloid_r * cos(((hypocycloid_R - hypocycloid_r) / hypocycloid_r) * tVal);
                float y = (hypocycloid_R - hypocycloid_r) * sin(tVal) - hypocycloid_r * sin(((hypocycloid_R - hypocycloid_r) / hypocycloid_r) * tVal);
                float z = hypocycloid_zAmplitude * sin(hypocycloid_zFrequency * tVal);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            R: this.R,
            r: this.r,
            zAmplitude: this.zAmplitude,
            zFrequency: this.zFrequency,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index / totalPoints) * Math.PI * 2;
        const x = (this.R - this.r) * Math.cos(tVal) + this.r * Math.cos(((this.R - this.r) / this.r) * tVal);
        const y = (this.R - this.r) * Math.sin(tVal) - this.r * Math.sin(((this.R - this.r) / this.r) * tVal);
        const z = this.zAmplitude * Math.sin(this.zFrequency * tVal);
        return new THREE.Vector3(x, y, z);
    }
}









class CardioidEquation extends EquationBase {
    constructor() {
        super();
        this.id = "cardioid";           // Unique identifier for shader integration
        this.a = 80;                    // Scale factor for the cardioid
        this.zAmplitude = 20;           // Z-axis amplitude
        this.zFrequency = 1.0;          // Z-axis frequency
        this.t = 0;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_cardioid(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * cardioid_speed * globalSpeed;
                float theta = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float r = cardioid_a * (1.0 + cos(theta));
                float x = r * cos(theta);
                float y = r * sin(theta);
                float z = cardioid_zAmplitude * sin(cardioid_zFrequency * theta);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            a: this.a,
            zAmplitude: this.zAmplitude,
            zFrequency: this.zFrequency,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const theta = this.t + (index / totalPoints) * Math.PI * 2;
        const r = this.a * (1 + Math.cos(theta));
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        const z = this.zAmplitude * Math.sin(this.zFrequency * theta);
        return new THREE.Vector3(x, y, z);
    }
}











class LemniscateEquation extends EquationBase {
    constructor() {
        super();
        this.id = "lemniscate";         // Unique identifier for shader integration
        this.a = 80;                    // Scale factor for the lemniscate
        this.zAmplitude = 20;           // Z-axis amplitude
        this.zFrequency = 1.0;          // Z-axis frequency
        this.t = 0;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

    getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_lemniscate(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * lemniscate_speed * globalSpeed;
                float theta = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float denominator = 1.0 + pow(sin(theta), 2.0);
                float x = lemniscate_a * cos(theta) / denominator;
                float y = lemniscate_a * sin(theta) * cos(theta) / denominator;
                float z = lemniscate_zAmplitude * cos(lemniscate_zFrequency * theta);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            a: this.a,
            zAmplitude: this.zAmplitude,
            zFrequency: this.zFrequency,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const theta = this.t + (index / totalPoints) * Math.PI * 2;
        const denominator = 1 + Math.pow(Math.sin(theta), 2);
        const x = this.a * Math.cos(theta) / denominator;
        const y = this.a * Math.sin(theta) * Math.cos(theta) / denominator;
        const z = this.zAmplitude * Math.cos(this.zFrequency * theta);
        return new THREE.Vector3(x, y, z);
    }
}











class ButterflyEquation extends EquationBase {
    constructor() {
        super();
        this.id = "butterfly";          // Unique identifier for shader integration
        this.scale = 40;                // Overall scale for the butterfly shape
        this.zAmplitude = 20;           // Z-axis amplitude
        this.zFrequency = 1.0;          // Z-axis frequency
        this.t = 0;
	this.globalSpeed = window.GLOBAL_SPEED;
    }

getContributionShader(indexVar, totalPointsVar, timeVar) {
        return `
            vec3 compute_butterfly(float ${indexVar}, float ${totalPointsVar}, float ${timeVar}) {
                float localT = ${timeVar} * butterfly_speed * globalSpeed;
                float tVal = localT + (${indexVar} / ${totalPointsVar}) * 3.1415926535 * 2.0;
                float butterflyCommon = exp(cos(tVal)) - 2.0 * cos(4.0 * tVal) - pow(sin(tVal / 12.0), 5.0);
                float x = butterfly_scale * sin(tVal) * butterflyCommon;
                float y = butterfly_scale * cos(tVal) * butterflyCommon;
                float z = butterfly_zAmplitude * sin(butterfly_zFrequency * tVal);
                return vec3(x, y, z);
            }
        `;
    }

    getUniforms() {
        return {
            scale: this.scale,
            zAmplitude: this.zAmplitude,
            zFrequency: this.zFrequency,
            speed: this.speed
        };
    }

    getContribution(index, totalPoints, time) {
        this.t = time * this.speed;
        const tVal = this.t + (index / totalPoints) * Math.PI * 2;
        const common = Math.exp(Math.cos(tVal)) - 2 * Math.cos(4 * tVal) - Math.pow(Math.sin(tVal / 12), 5);
        const x = this.scale * Math.sin(tVal) * common;
        const y = this.scale * Math.cos(tVal) * common;
        const z = this.zAmplitude * Math.sin(this.zFrequency * tVal);
        return new THREE.Vector3(x, y, z);
    }
}






class IntegrationModule {
    constructor(scene, eqModules, camera) {
        console.log('Creating IntegrationModule with camera:', camera);
        
        this.scene = scene;
        this.eqModules = eqModules;
        this.camera = camera;
        this.renderer = null;
        this.geometry = null;
        this.material = null;
        this.points = null;
        this.instancedMesh = null;
        this.initialized = false;
    }

    setRenderer(renderer) {
        this.renderer = renderer;
    }

    initializeGPU(pointCount) {
        if (this.initialized) {
            this.cleanup();
        }
        this.initialized = false;
        this.setupGeometry(pointCount);
        this.eqModules.forEach(mod => {
            if (mod.instance.isStateful && mod.instance.enabled) {
                mod.instance.initializeState(this.renderer, pointCount);
            }
        });
        this.initialized = true;
        console.log('GPU initialized with pointCount:', pointCount);
    }

    cleanup() {
        if (this.points) {
            this.scene.remove(this.points);
            this.geometry.dispose();
            this.material.dispose();
            this.points = null;
        }
        if (this.instancedMesh) {
            this.scene.remove(this.instancedMesh);
            this.geometry.dispose();
            this.material.dispose();
            this.instancedMesh = null;
        }
        this.geometry = null;
        this.material = null;
        this.initialized = false;
        console.log('Cleanup completed');
    }

    setupGeometry(pointCount) {
        const useGlow = true;

        if (useGlow) {
            if (this.instancedMesh) {
                this.scene.remove(this.instancedMesh);
                this.instancedMesh.geometry.dispose();
                this.instancedMesh.material.dispose();
                this.instancedMesh = null;
            }
            const dummyPositions = new Float32Array(pointCount * 3);
            for (let i = 0; i < pointCount * 3; i++) {
                dummyPositions[i] = 0;
            }
            const indices = new Float32Array(pointCount);
            for (let i = 0; i < pointCount; i++) indices[i] = i;

            this.geometry = new THREE.BufferGeometry();
            this.geometry.setAttribute('position', new THREE.BufferAttribute(dummyPositions, 3));
            this.geometry.setAttribute('index', new THREE.BufferAttribute(indices, 1));

            this.material = new THREE.ShaderMaterial({
                uniforms: {
                    ...this.buildUniforms(pointCount),
                    pointTexture: { value: this.generateDotTexture() }
                },
                vertexShader: this.buildVertexShader(),
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
                        if (texColor.a < 0.1) discard;
                        gl_FragColor = vec4(vColor * texColor.rgb, opacity * texColor.a);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthTest: true,
                depthWrite: false,
            });
            this.points = new THREE.Points(this.geometry, this.material);
            this.scene.add(this.points);
            this.initialized = true;
            console.log('Points added, initialized:', this.initialized);
        } else {
            if (this.points) {
                this.scene.remove(this.points);
                this.geometry.dispose();
                this.material.dispose();
                this.points = null;
            }
            const sphereGeom = new THREE.SphereGeometry(1, 16, 16);
            this.geometry = new THREE.InstancedBufferGeometry();
            this.geometry.copy(sphereGeom);
            const indices = new Float32Array(pointCount);
            for (let i = 0; i < pointCount; i++) indices[i] = i;
            const instanceIndexAttr = new THREE.InstancedBufferAttribute(indices, 1);
            this.geometry.setAttribute('instanceIndex', instanceIndexAttr);
            console.log('After setting instanceIndex:', {
                instanceIndexExists: !!this.geometry.attributes.instanceIndex,
                instanceIndexCount: this.geometry.attributes.instanceIndex ? this.geometry.attributes.instanceIndex.count : 'N/A'
            });
            this.material = new THREE.ShaderMaterial({
                uniforms: this.buildUniforms(pointCount),
                vertexShader: this.buildVertexShader(true),
                fragmentShader: `
                    uniform vec3 lightPos;
                    uniform vec3 lightColor;
                    uniform float emissiveIntensity;
                    varying vec3 vColor;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vec3 normal = normalize(vNormal);
                        vec3 lightDir = normalize(lightPos - vPosition);
                        float diff = max(dot(normal, lightDir), 0.0);
                        vec3 diffuse = diff * lightColor * vColor;
                        vec3 emissive = vColor * emissiveIntensity;
                        gl_FragColor = vec4(diffuse + emissive, 1.0);
                    }
                `,
                side: THREE.FrontSide,
            });
            this.instancedMesh = new THREE.InstancedMesh(this.geometry, this.material, pointCount);
            this.scene.add(this.instancedMesh);
            console.log('InstancedMesh setup complete:', {
                geometryExists: !!this.geometry,
                instanceCount: this.instancedMesh.count,
                instanceIndexSet: !!this.geometry.attributes.instanceIndex,
                instanceIndexCount: this.geometry.attributes.instanceIndex ? this.geometry.attributes.instanceIndex.count : 'N/A',
                instanceIndexArray: this.geometry.attributes.instanceIndex ? this.geometry.attributes.instanceIndex.array.slice(0, 5) : 'N/A'
            });
            this.initialized = true;
            console.log('InstancedMesh added, initialized:', this.initialized);
        }
    }

    buildUniforms(pointCount) {
        const uniforms = {
            time: { value: 0 },
            totalPoints: { value: pointCount },
            size: { value: 4.0 },
            globalSpeed: { value: window.GLOBAL_SPEED || 1.0 },
            soundMod: { value: 0 },
            sensitivity: { value: 0.25 },
            expansionFactor: { value: 2 },
            baseHue: { value: 180 },
            opacity: { value: 1.0 },
            lightPos: { value: new THREE.Vector3(100, 100, 100) },
            lightColor: { value: new THREE.Color(0xffffff) },
            emissiveIntensity: { value: 0.15 },
            frustumPlanes: { value: [new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()] },
        };

        this.eqModules.forEach(mod => {
            uniforms[`equation_${mod.id}_enabled`] = { value: mod.instance.enabled ? 1.0 : 0.0 };
            const eqUniforms = mod.instance.getUniforms() || {};
            for (const [key, value] of Object.entries(eqUniforms)) {
                uniforms[`${mod.id}_${key}`] = { value: value };
            }
            if (mod.instance.isStateful) {
                mod.instance.getStateSamplerNames().forEach(name => {
                    uniforms[name] = { value: mod.instance.stateTexture ? mod.instance.stateTexture.texture : null };
                });
                uniforms[`${mod.id}_gridSize`] = { value: mod.instance.gridSize };
            }
        });

        return uniforms;
    }

    buildVertexShader(isInstanced = false) {
        let computeFunctions = '';
        let sumContributions = '';
        let uniforms = `
            uniform float time;
            uniform float totalPoints;
            uniform float size;
            uniform float globalSpeed;
            uniform float soundMod;
            uniform float sensitivity;
            uniform float expansionFactor;
            uniform float baseHue;
            uniform vec4 frustumPlanes[6];
        `;

        this.eqModules.forEach(mod => {
            uniforms += `uniform float equation_${mod.id}_enabled;\n`;
            const eqUniforms = mod.instance.getUniforms() || {};
            for (const [key, value] of Object.entries(eqUniforms)) {
                let type = typeof value === 'number' ? 'float' : `float[${value.length}]`;
                uniforms += `uniform ${type} ${mod.id}_${key};\n`;
            }
            if (mod.instance.isStateful) {
                mod.instance.getStateSamplerNames().forEach(name => {
                    uniforms += `uniform sampler2D ${name};\n`;
                });
                uniforms += `uniform float ${mod.id}_gridSize;\n`;
                const fn = mod.instance.getContributionFromState('gridIndex', 'totalPoints', 'time', mod.instance.getStateSamplerNames());
                computeFunctions += fn.includes('float') ? fn : `
                    vec3 compute_${mod.id}(float gridIndex, float totalPoints, float time) {
                        return vec3(0.0);
                    }
                `;
                sumContributions += `
                    if (equation_${mod.id}_enabled > 0.5) {
                        float gridTotal = ${mod.id}_gridSize * ${mod.id}_gridSize;
                        float gridIndex = floor((index / totalPoints) * gridTotal);
                        position += compute_${mod.id}(gridIndex, totalPoints, time);
                    }
                `;
            } else {
                const fn = mod.instance.getContributionShader('index', 'totalPoints', 'time');
                computeFunctions += fn.includes('float') ? fn : `
                    vec3 compute_${mod.id}(float index, float totalPoints, float time) {
                        return vec3(0.0);
                    }
                `;
                sumContributions += `
                    if (equation_${mod.id}_enabled > 0.5) {
                        position += compute_${mod.id}(index, totalPoints, time);
                    }
                `;
            }
        });

        return `
            ${uniforms}

            attribute ${isInstanced ? 'float instanceIndex' : 'float index'};
            varying vec3 vColor;

            float noise(float x, float y, float z, float seed) {
                float value = sin(x * 12.9898 + y * 78.233 + z * 37.719 + seed * 43758.5453);
                return fract(value);
            }

            vec3 hslToRgb(float h, float s, float l) {
                float c = (1.0 - abs(2.0 * l - 1.0)) * s;
                float hPrime = h / 60.0;
                float x = c * (1.0 - abs(mod(hPrime, 2.0) - 1.0));
                float m = l - c / 2.0;
                vec3 rgb;
                if (hPrime < 1.0) rgb = vec3(c, x, 0.0);
                else if (hPrime < 2.0) rgb = vec3(x, c, 0.0);
                else if (hPrime < 3.0) rgb = vec3(0.0, c, x);
                else if (hPrime < 4.0) rgb = vec3(0.0, x, c);
                else if (hPrime < 5.0) rgb = vec3(x, 0.0, c);
                else rgb = vec3(c, 0.0, x);
                return rgb + vec3(m);
            }

            ${computeFunctions}

            vec3 computePosition(float index) {
                vec3 position = vec3(0.0);
                float t = time * globalSpeed;
                ${sumContributions}
                return position;
            }

            bool isPointInFrustum(vec3 point) {
                for (int i = 0; i < 6; i++) {
                    vec4 plane = frustumPlanes[i];
                    if (dot(vec3(plane.xyz), point) + plane.w < 0.0) {
                        return false;
                    }
                }
                return true;
            }

            void main() {
                float idx = ${isInstanced ? 'instanceIndex' : 'index'};
                vec3 position = computePosition(idx);
                if (!isPointInFrustum(position)) {
                    gl_Position = vec4(0.0);
                    gl_PointSize = 0.0;
                } else {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    float modulatedSize = size;
                    if (soundMod > 0.0) {
                        modulatedSize *= (1.0 + soundMod * expansionFactor);
                    }
                    gl_PointSize = modulatedSize;
                    float tNorm = idx / (totalPoints - 1.0);
                    float hueVariation = 10.0 * sin(tNorm * 6.28318530718);
                    float hue = mod(baseHue + hueVariation, 360.0);
                    float lightness = 0.3 + tNorm * 0.4;
                    vColor = hslToRgb(hue, 0.8, lightness);
                }
            }
        `;
    }

    generateDotTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        const centerX = 32;
        const centerY = 32;
        const radius = 32;
        
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        const stops = [
            { pos: parseFloat(document.getElementById('glowStop0Pos').value), alpha: parseFloat(document.getElementById('glowStop0Alpha').value) },
            { pos: parseFloat(document.getElementById('glowStop1Pos').value), alpha: parseFloat(document.getElementById('glowStop1Alpha').value) },
            { pos: parseFloat(document.getElementById('glowStop2Pos').value), alpha: parseFloat(document.getElementById('glowStop2Alpha').value) },
            { pos: parseFloat(document.getElementById('glowStop3Pos').value), alpha: parseFloat(document.getElementById('glowStop3Alpha').value) },
        ];
        
        stops.forEach(stop => {
            gradient.addColorStop(stop.pos, `rgba(255, 255, 255, ${stop.alpha})`);
        });
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        
        return texture;
    }

    update(deltaTime, globalTime) {
        if (!this.initialized) {
            console.log('Skipping update: geometry not yet initialized');
            return;
        }
        const pointCount = parseInt(document.getElementById('globalPointCount').value) || 30000;
        const attrName = 'index';
        if (!this.geometry || !this.geometry.attributes || !this.geometry.attributes[attrName] || this.geometry.attributes[attrName].count !== pointCount) {
            console.warn('Reinitializing with pointCount:', pointCount);
            this.initializeGPU(pointCount);
        }

        console.log('baseHue:', this.material.uniforms.baseHue.value);

        const effectiveCamera = this.camera || (window.visualization && window.visualization.camera);
        if (!effectiveCamera) {
            console.error('No valid camera available in IntegrationModule.update', {
                thisCamera: this.camera,
                windowVisualization: window.visualization,
                windowVisualizationCamera: window.visualization?.camera
            });
            return;
        }

        const frustum = new THREE.Frustum();
        frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(
            effectiveCamera.projectionMatrix,
            effectiveCamera.matrixWorldInverse
        ));
        for (let i = 0; i < 6; i++) {
            const plane = frustum.planes[i];
            this.material.uniforms.frustumPlanes.value[i].set(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
        }

        this.eqModules.forEach(mod => {
            if (mod.instance.isStateful && mod.instance.enabled) {
                mod.instance.updateState(this.renderer, deltaTime, globalTime);
            }
            const eqUniforms = mod.instance.getUniforms() || {};
            for (const [key, value] of Object.entries(eqUniforms)) {
                this.material.uniforms[`${mod.id}_${key}`].value = value;
            }
        });

        this.material.uniforms.time.value = globalTime;
        this.material.uniforms.soundMod.value = window.soundMod || 0;
        this.material.uniforms.sensitivity.value = parseFloat(document.getElementById('soundSensitivity').value) || 0.25;
        this.material.uniforms.expansionFactor.value = parseFloat(document.getElementById('soundExpansionFactor').value) || 2;
        this.material.uniforms.baseHue.value = parseFloat(document.getElementById('globalColor').value) || 180;
        this.material.uniforms.size.value = (parseFloat(document.getElementById('globalSphereSize').value) || 1.0) * 4.0;

        if (this.points) {
            if (document.getElementById("soundEffectEmissive").checked) {
                let sensitivity = parseFloat(document.getElementById("soundSensitivity").value) || 0.25;
                this.material.uniforms.opacity.value = Math.min(0.15 + (window.soundMod || 0) * sensitivity, 1.0);
            } else {
                this.material.uniforms.opacity.value = 1.0;
            }
        }

        if (this.instancedMesh) {
            if (document.getElementById("soundEffectEmissive").checked) {
                let sensitivity = parseFloat(document.getElementById("soundSensitivity").value) || 0.25;
                this.material.uniforms.emissiveIntensity.value = (window.soundMod || 0) * sensitivity;
            } else {
                this.material.uniforms.emissiveIntensity.value = 0.15;
            }
        }

        this.eqModules.forEach(mod => {
            this.material.uniforms[`equation_${mod.id}_enabled`].value = mod.instance.enabled ? 1.0 : 0.0;
        });

        this.material.uniformsNeedUpdate = true;
    }
}








    /**************** SoundModule ****************/
    class SoundModule {
      constructor(){
        this.enabled = false;
        this.sensitivity = 0.25;
        this.frequencyData = null;
        this.analyser = null;
        this.audioContext = null;
      }
      async init(){
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = this.audioContext.createMediaStreamSource(stream);
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 2048;
          const bufferLength = this.analyser.frequencyBinCount;
          this.frequencyData = new Float32Array(bufferLength);
          source.connect(this.analyser);
          this.enabled = true;
          document.getElementById('soundStatus').textContent = "Audio running...";
        } catch(err){
          console.error('Audio initialization error:', err);
          document.getElementById('soundStatus').textContent = "Audio access denied.";
        }
      }
      update(deltaTime){
        if(!this.enabled || !this.analyser) return;
        this.analyser.getFloatFrequencyData(this.frequencyData);
        let maxDb = -Infinity;
        for(let i = 0; i < this.frequencyData.length; i++){
          if(this.frequencyData[i] > maxDb) maxDb = this.frequencyData[i];
        }
        const THRESHOLD_DB = -60;
        window.soundMod = maxDb < THRESHOLD_DB ? 0 : (maxDb - THRESHOLD_DB)/(0 - THRESHOLD_DB);
        let bassMax = -Infinity;
        for(let i = 0; i < 40; i++){
          if(this.frequencyData[i] > bassMax) bassMax = this.frequencyData[i];
        }
        window.soundModBass = bassMax < THRESHOLD_DB ? 0 : (bassMax - THRESHOLD_DB)/(0 - THRESHOLD_DB);
        let midMax = -Infinity;
        for(let i = 41; i < 200 && i < this.frequencyData.length; i++){
          if(this.frequencyData[i] > midMax) midMax = this.frequencyData[i];
        }
        window.soundModMid = midMax < THRESHOLD_DB ? 0 : (midMax - THRESHOLD_DB)/(0 - THRESHOLD_DB);
        let highMax = -Infinity;
        for(let i = 300; i < this.frequencyData.length; i++){
          if(this.frequencyData[i] > highMax) highMax = this.frequencyData[i];
        }
        window.soundModHigh = highMax < THRESHOLD_DB ? 0 : (highMax - THRESHOLD_DB)/(0 - THRESHOLD_DB);
      }
      getOutput(){
        return { frequencyData: this.frequencyData };
      }
      setParameters(params){
        if(params.sensitivity!==undefined) this.sensitivity = params.sensitivity;
      }
    }

    /**************** Persistent Settings & Favorites ****************/
function saveSettings() {
  const settings = {};
  
  // **Capture Control Panel inputs**
  document.querySelectorAll('#controlPanel input').forEach(input => {
    if (input.id === "fullscreenToggle" || input.id === "screenStaysActive") return;
    if (input.type === "checkbox") {
      settings[input.id] = input.checked;
    } else {
      settings[input.id] = input.value;
    }
  });
  
  // **Capture Control Panel select elements**
  document.querySelectorAll('#controlPanel select').forEach(select => {
    settings[select.id] = select.value;
  });
  
  // **Capture visualization data (camera and equation states)**
  if (window.visualization) {
    settings.camera = {
      position: {
        x: window.visualization.camera.position.x,
        y: window.visualization.camera.position.y,
        z: window.visualization.camera.position.z
      },
      zoom: window.visualization.camera.zoom,
      controlsTarget: {
        x: window.visualization.controls.target.x,
        y: window.visualization.controls.target.y,
        z: window.visualization.controls.target.z
      }
    };
    
    // Save internal states of all active equations
    settings.visualization = {
      equations: {}
    };
    window.visualization.eqModules.forEach(mod => {
      settings.visualization.equations[mod.id] = mod.instance.serializeState();
    });
  }
  
  // **Save to file via Electron API**
  window.electronAPI.saveSettings(settings).then(result => {
    if (!result.success) console.error("Failed to save settings:", result.error);
  });
}
window.saveSettings = saveSettings;








  // Save a favorite – now using the electronAPI for favorites.
function saveFavorite() {
  const fav = {};
  document.querySelectorAll('#controlPanel input').forEach(input => {
    if (input.id === "fullscreenToggle") return;
    if (input.id === "slideshowRandom" || input.id === "slideshowInterval") return;
    fav[input.id] = (input.type === "checkbox") ? input.checked : input.value;
  });
  document.querySelectorAll('#controlPanel select').forEach(select => {
    fav[select.id] = select.value;
  });
  if (window.visualization) {
    fav.camera = {
      position: { x: window.visualization.camera.position.x, y: window.visualization.camera.position.y, z: window.visualization.camera.position.z },
      zoom: window.visualization.camera.zoom,
      controlsTarget: { x: window.visualization.controls.target.x, y: window.visualization.controls.target.y, z: window.visualization.controls.target.z }
    };
  }
  if (window.visualization && window.visualization.eqModules) {
    fav.equations = {};
    window.visualization.eqModules.forEach(mod => {
      fav.equations[mod.id] = mod.instance.serializeState();
    });
  }

  const settingsKey = JSON.stringify({ ...fav, thumbnail: null });
  window.electronAPI.loadFavorites().then(favorites => {
    if (!Array.isArray(favorites)) favorites = [];
    const existingFavIndex = favorites.findIndex(f => {
      const existingKey = JSON.stringify({ ...f, thumbnail: null });
      return existingKey === settingsKey;
    });
    if (existingFavIndex === -1) {
      const thumbnail = captureFavoriteThumbnail();
      if (!thumbnail) console.warn("Thumbnail capture failed for new favorite");
      fav.thumbnail = thumbnail;
      favorites.push(fav);
    } else {
      if (!favorites[existingFavIndex].thumbnail) {
        const thumbnail = captureFavoriteThumbnail();
        if (!thumbnail) console.warn("Thumbnail capture failed for existing favorite");
        favorites[existingFavIndex].thumbnail = thumbnail;
      }
      favorites[existingFavIndex] = { ...fav, thumbnail: favorites[existingFavIndex].thumbnail };
    }
    window.electronAPI.saveFavorites(favorites).then(result => {
      if (result.success) {
        console.log("Favorites saved:", favorites); // Debug log
        updateFavoriteList();
      } else {
        console.error("Failed to save favorite:", result.error);
      }
    });
  });
}








function exportSingleFavorite(favorite) {
  const now = new Date();
  const pad = (n) => n.toString().padStart(2, '0');
  const timestamp = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
  const filename = `PuLsE-single-fav-${timestamp}.json`;
  let blob = new Blob([JSON.stringify([favorite])], { type: "application/json" });
  let url = URL.createObjectURL(blob);
  let a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}







  // Update the list of favorites from the stored data.
function updateFavoriteList() {
  window.electronAPI.loadFavorites().then(favorites => {
    console.log("Favorites loaded for list:", favorites); // Debug log
    const favList = document.getElementById('favoriteList');
    favList.innerHTML = '';
    favorites.forEach((fav, index) => {
      const li = document.createElement('li');
      li.style.display = 'flex';
      li.style.alignItems = 'center';
      if (fav.thumbnail) {
        console.log(`Thumbnail for Favorite ${index + 1}:`, fav.thumbnail.substring(0, 50)); // Log first 50 chars
        const img = document.createElement('img');
        img.src = fav.thumbnail;
        img.width = 32;
        img.height = 32;
        img.style.marginRight = '5px';
        li.appendChild(img);
      } else {
        console.log(`No thumbnail for Favorite ${index + 1}`);
        const placeholder = document.createElement('div');
        placeholder.style.width = '32px';
        placeholder.style.height = '32px';
        placeholder.style.background = '#555';
        placeholder.style.marginRight = '5px';
        li.appendChild(placeholder);
      }
      const textSpan = document.createElement('span');
      textSpan.textContent = (index + 1);
      li.appendChild(textSpan);
      const loadBtn = document.createElement('button');
      loadBtn.textContent = 'Load';
      loadBtn.addEventListener('click', () => {
        document.body.style.opacity = "0";
        setTimeout(() => {
          for (const id in fav) {
            if (id === "camera" || id === "fullscreenToggle" || id === "thumbnail") continue;
            const element = document.getElementById(id);
            if (element) {
              if (element.type === "checkbox") {
                element.checked = fav[id];
                element.dispatchEvent(new Event('change'));
              } else {
                element.value = fav[id];
                element.dispatchEvent(new Event('input'));
              }
            }
          }
          if (fav.camera && window.visualization) {
            const cam = fav.camera;
            window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
            window.visualization.camera.zoom = cam.zoom;
            window.visualization.camera.updateProjectionMatrix();
            window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
            window.visualization.controls.update();
          }
          if (window.visualization && window.visualization.eqModules && fav.equations) {
            window.visualization.eqModules.forEach(mod => {
              if (fav.equations[mod.id] !== undefined) {
                mod.instance.deserializeState(fav.equations[mod.id]);
              }
            });
          }
          saveSettings();
          document.body.style.opacity = "1";
        }, 500);
      });
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.addEventListener('click', () => { deleteFavorite(index); });
      li.appendChild(loadBtn);



const exportBtn = document.createElement('button');
exportBtn.textContent = 'Export';
exportBtn.title = 'Export this favorite';
exportBtn.addEventListener('click', () => {
  exportSingleFavorite(fav);
});
li.appendChild(exportBtn);


      li.appendChild(delBtn);
      favList.appendChild(li);
    });
  });
}
    // Expose updateFavoriteList to the global scope so non-module scripts can access it.
    window.updateFavoriteList = updateFavoriteList;



  // Delete a favorite at a given index.
  function deleteFavorite(index){
    window.electronAPI.loadFavorites().then(favorites => {
      favorites.splice(index, 1);
      window.electronAPI.saveFavorites(favorites).then(result => {
        updateFavoriteList();
      });
    });
  }


    // ADDED: Modified loadFavoriteForSlideshow() to also restore internal state.
function loadFavoriteForSlideshow(fav) {
    // Start fade-out transition
    document.body.style.transition = "opacity 0.5s ease";
    document.body.style.opacity = "0";

    setTimeout(() => {
        // Step 1: Apply favorite settings to UI elements
        for (const id in fav) {
            if (id === "camera" || id === "fullscreenToggle" || id === "slideshowRandom" || id === "slideshowInterval") continue;
            const element = document.getElementById(id);
            if (element) {
                if (element.type === "checkbox") {
                    element.checked = fav[id];
                    element.dispatchEvent(new Event('change'));
                } else {
                    element.value = fav[id];
                    element.dispatchEvent(new Event('input'));
                }
            }
        }

        // Step 2: Update camera settings if provided
        if (fav.camera && window.visualization) {
            const cam = fav.camera;
            window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
            window.visualization.camera.zoom = cam.zoom;
            window.visualization.camera.updateProjectionMatrix();
            window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
            window.visualization.controls.update();
        }

        // Step 3: Update equation modules
        if (window.visualization && window.visualization.eqModules) {
            // Reset all equations to false
            window.visualization.eqModules.forEach(mod => {
                mod.instance.enabled = false; // Default to disabled
                const checkbox = document.getElementById(`${mod.id}_enable`);
                if (checkbox) {
                    checkbox.checked = false;
                    checkbox.dispatchEvent(new Event('change')); // Ensure UI and state sync
                }
            });

            // Enable only equations explicitly true in the favorite
            if (fav.equations) {
                window.visualization.eqModules.forEach(mod => {
                    if (fav.equations[mod.id] !== undefined) {
                        mod.instance.deserializeState(fav.equations[mod.id]);
                        // Explicitly set enabled state based on favorite data
                        const enabled = fav.equations[mod.id].enabled === true;
                        mod.instance.enabled = enabled;
                        const checkbox = document.getElementById(`${mod.id}_enable`);
                        if (checkbox) {
                            checkbox.checked = enabled;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    }
                });
            }
        }

        // Step 4: Save the updated settings
        saveSettings();

        // Step 5: Restart the visualization to apply the new state
        if (window.visualization) {
            window.visualization.restart();
        }

        // Step 6: Fade back in
        document.body.style.opacity = "1";
    }, 500); // Delay matches the 0.5s fade-out duration
}



/**************** ControlPanel ****************/
class ControlPanel {
    constructor(eqModules, soundModule) {
        this.eqModules = eqModules;
        this.soundModule = soundModule;
        this.initPanel();
    }

    initPanel() {
        const categoryMap = {
            "lissajous": "paths",
            "roseCurve": "paths",
            "spiral": "paths",
            "fourierSeries": "paths",
            "torus": "paths",
            "epicycloid": "paths",
            "hypocycloid": "paths",
            "cardioid": "paths",
            "lemniscate": "paths",
            "butterfly": "paths",
            "sineDistortion": "distortions",
            "reactionDiffusion": "distortions",
            "phaseRipple": "distortions",
            "zSineWarp": "distortions",
            "radialTwist": "distortions",
            "shm": "distortions",
            "rossler": "distortions",
	    "fluidFlow": "distortions",
            "noiseEq": "noises",
            "fractalNoise": "noises",
            "ridgedNoise": "noises",
            "voronoiNoise": "noises"
        };

	const pointCountSlider = document.getElementById('globalPointCount');
        const pointCountDisplay = document.getElementById('pointCountDisplay');

        function updatePointCountDisplay() {
            const value = parseInt(pointCountSlider.value);
            pointCountDisplay.textContent = `${value.toLocaleString()} pts`;
        }

        // Initial update
        updatePointCountDisplay();

        pointCountSlider.addEventListener('input', (e) => {
            const count = parseInt(e.target.value);
            this.eqModules.forEach(mod => {
                if (mod.id !== "reactionDiffusion") {
                    mod.instance.setPointCount(count);
                }
            });
            updatePointCountDisplay();
            saveSettings();
        });


	// Global Speed update
        const globalSpeedSlider = document.getElementById('globalSpeed');
        const globalSpeedDisplay = document.getElementById('globalSpeedDisplay');

        function updateGlobalSpeedDisplay() {
            const value = parseFloat(globalSpeedSlider.value);
            globalSpeedDisplay.textContent = `Global Speed ${value.toFixed(2)}`;
        }

        // Initial update for global speed
        updateGlobalSpeedDisplay();

        globalSpeedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            if (
                window.visualization &&
                window.visualization.integrationModule &&
                window.visualization.integrationModule.material &&
                window.visualization.integrationModule.material.uniforms.globalSpeed
            ) {
                const integrationMod = window.visualization.integrationModule;
                integrationMod.material.uniforms.globalSpeed.value = speed;
                integrationMod.material.uniformsNeedUpdate = true;
            } else {
                console.log('Deferring globalSpeed update until initialization completes');
            }
            window.GLOBAL_SPEED = speed;
            updateGlobalSpeedDisplay(); // Update display on input
            saveSettings();
        });

        document.querySelector('.moduleHeader[data-target="globalSettings"]').addEventListener('click', function() {
            const content = document.getElementById('globalSettings');
            content.style.display = (content.style.display === 'block') ? 'none' : 'block';
        });

        // Add TAA listeners
        document.getElementById('taaEnable').addEventListener('change', (e) => {
            window.visualization.taaPass.enabled = e.target.checked;
            console.log('TAA Enabled:', window.visualization.taaPass.enabled);
        });
        document.getElementById('taaQuality').addEventListener('input', (e) => {
            window.visualization.taaPass.sampleLevel = parseInt(e.target.value);
        });

        document.getElementById('fullscreenToggle').addEventListener('change', (e) => {
            if (e.target.checked) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        });

        // Glow Points Settings Toggle
        const glowPointsHeader = document.getElementById('glowPointsHeader');
        const glowPointsSettings = document.getElementById('glowPointsSettings');

        glowPointsHeader.addEventListener('click', () => {
            glowPointsSettings.style.display = (
                glowPointsSettings.style.display === 'block'
            ) ? 'none' : 'block';
        });

        // Glow Points Settings Inputs
        ['glowStop0Pos', 'glowStop0Alpha',
         'glowStop1Pos', 'glowStop1Alpha',
         'glowStop2Pos', 'glowStop2Alpha',
         'glowStop3Pos', 'glowStop3Alpha'
        ].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                saveSettings();
                const integrationMod = window.visualization.integrationModule;
                if (integrationMod && integrationMod.material && integrationMod.points) {
                    if (integrationMod.material.uniforms && integrationMod.material.uniforms.pointTexture?.value) {
                        integrationMod.material.uniforms.pointTexture.value.dispose();
                    }
                    integrationMod.material.uniforms.pointTexture.value = integrationMod.generateDotTexture();
                    integrationMod.material.uniformsNeedUpdate = true;
                }
            });
        });




        const colorMap = {
            "rossler": "#2b2b2b",
            "roseCurve": "#3c3c3c",
            "spiral": "#3c3c3c",
            "torus": "#3c3c3c",
            "fourierSeries": "#3c3c3c",
            "lissajous": "#3c3c3c",
            "epicycloid": "#3c3c3c",
            "hypocycloid": "#3c3c3c",
            "cardioid": "#3c3c3c",
            "lemniscate": "#3c3c3c",
            "butterfly": "#3c3c3c",
            "sineDistortion": "#4d4d4d",
            "reactionDiffusion": "#4d4d4d",
            "phaseRipple": "#4d4d4d",
            "zSineWarp": "#4d4d4d",
            "radialTwist": "#4d4d4d",
            "shm": "#4d4d4d",
            "noiseEq": "#5e5e5e",
            "fractalNoise": "#5e5e5e",
            "ridgedNoise": "#5e5e5e",
	    "fluidFlow": "#4d4d4d",
            "voronoiNoise": "#5e5e5e"
        };

        this.eqModules.forEach(mod => {
            const header = document.createElement('div');
            header.className = 'moduleHeader';
            if (colorMap[mod.id]) {
                header.style.background = colorMap[mod.id];
            }
            const titleSpan = document.createElement('span');
            titleSpan.textContent = mod.name;
            header.appendChild(titleSpan);
            const enableCheckbox = document.createElement('input');
            enableCheckbox.type = "checkbox";
            enableCheckbox.id = mod.id + "_enable";
            enableCheckbox.checked = mod.instance.enabled;
            header.appendChild(enableCheckbox);

            console.log(`Created checkbox ${enableCheckbox.id} for ${mod.id}`);

            enableCheckbox.addEventListener('change', (e) => {
                console.log(`${mod.id} enabled changed to: ${e.target.checked}`);
                mod.instance.enabled = e.target.checked;
                saveSettings();
                if (e.target.checked && mod.instance.isStateful && window.visualization && window.visualization.integrationModule) {
                    const pointCount = parseInt(document.getElementById('globalPointCount').value) || 30000;
                    window.visualization.integrationModule.initializeGPU(pointCount);
                }
            });

            const content = document.createElement('div');
            content.className = 'moduleContent';
            content.id = mod.id;
            let innerHTML = "";

            if (mod.id !== "rossler") {
                innerHTML += `
                    <div class="controlElement">
                        <label>Speed: <input type="range" id="${mod.id}_speed" min="0" max="3.0" step="0.001" value="${mod.instance.speed}"></label>
                    </div>
                `;
            }

            switch (mod.id) {
                case "lissajous":
                    innerHTML += `
                        <div class="controlElement">
                            <label>A: <input type="range" id="${mod.id}_A" min="10" max="100" step=".001" value="${mod.instance.A}"></label>
                        </div>
                        <div class="controlElement">
                            <label>B: <input type="range" id="${mod.id}_B" min="10" max="100" step=".001" value="${mod.instance.B}"></label>
                        </div>
                        <div class="controlElement">
                            <label>a: <input type="range" id="${mod.id}_a" min="1" max="10" step=".001" value="${mod.instance.a}"></label>
                        </div>
                        <div class="controlElement">
                            <label>b: <input type="range" id="${mod.id}_b" min="1" max="10" step=".001" value="${mod.instance.b}"></label>
                        </div>
                        <div class="controlElement">
                            <label>δ: <input type="range" id="${mod.id}_delta" min="0" max="6.28" step="0.001" value="${mod.instance.delta.toFixed(2)}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_A`).addEventListener('input', (e) => {
                        mod.instance.A = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_B`).addEventListener('input', (e) => {
                        mod.instance.B = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => {
                        mod.instance.a = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_b`).addEventListener('input', (e) => {
                        mod.instance.b = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_delta`).addEventListener('input', (e) => {
                        mod.instance.delta = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "roseCurve":
                    innerHTML += `
                        <div class="controlElement">
                            <label>A: <input type="range" id="${mod.id}_A" min="10" max="200" step=".001" value="${mod.instance.A}"></label>
                        </div>
                        <div class="controlElement">
                            <label>k: <input type="range" id="${mod.id}_k" min="1" max="10" step=".001" value="${mod.instance.k}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_A`).addEventListener('input', (e) => {
                        mod.instance.A = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_k`).addEventListener('input', (e) => {
                        mod.instance.k = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "spiral":
                    innerHTML += `
                        <div class="controlElement">
                            <label>a: <input type="range" id="${mod.id}_a" min="0" max="20" step="0.001" value="${mod.instance.a}"></label>
                        </div>
                        <div class="controlElement">
                            <label>b: <input type="range" id="${mod.id}_b" min="0" max="20" step="0.001" value="${mod.instance.b}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => {
                        mod.instance.a = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_b`).addEventListener('input', (e) => {
                        mod.instance.b = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "fourierSeries":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Amplitude Factor: <input type="range" id="${mod.id}_amp" min="5" max="50" step=".001" value="${mod.instance.baseAmp}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Number of Terms: <input type="range" id="${mod.id}_terms" min="1" max="20" step=".001" value="${mod.instance.numTerms}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_amp`).addEventListener('input', (e) => {
                        mod.instance.baseAmp = parseFloat(e.target.value);
                        for (let n = 1; n <= mod.instance.numTerms; n++) {
                            mod.instance.A[n - 1] = mod.instance.baseAmp / n;
                        }
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_terms`).addEventListener('input', (e) => {
                        mod.instance.numTerms = parseInt(e.target.value);
                        mod.instance.A = [];
                        mod.instance.phases = [];
                        for (let n = 1; n <= mod.instance.numTerms; n++) {
                            mod.instance.A.push(mod.instance.baseAmp / n);
                            mod.instance.phases.push(Math.random() * Math.PI * 2);
                        }
                        saveSettings();
                    });
                    break;

                case "shm":
                    innerHTML += `
                        <div class="controlElement">
                            <label>A: <input type="range" id="${mod.id}_A" min="10" max="100" step=".001" value="${mod.instance.A}"></label>
                        </div>
                        <div class="controlElement">
                            <label>ω: <input type="range" id="${mod.id}_omega" min="0.5" max="5" step="0.001" value="${mod.instance.omega}"></label>
                        </div>
                        <div class="controlElement">
                            <label>ϕ: <input type="range" id="${mod.id}_phi" min="0" max="6.28" step="0.001" value="${mod.instance.phi}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_A`).addEventListener('input', (e) => {
                        mod.instance.A = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_omega`).addEventListener('input', (e) => {
                        mod.instance.omega = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_phi`).addEventListener('input', (e) => {
                        mod.instance.phi = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "reactionDiffusion":
                    innerHTML += `
                        <div class="controlElement">
                            <label>F: <input type="range" id="${mod.id}_F" min="0.01" max="0.1" step="0.001" value="${mod.instance.F}"></label>
                        </div>
                        <div class="controlElement">
                            <label>k: <input type="range" id="${mod.id}_k" min="0.01" max="0.1" step="0.001" value="${mod.instance.k}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_F`).addEventListener('input', (e) => {
                        mod.instance.F = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_k`).addEventListener('input', (e) => {
                        mod.instance.k = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "noiseEq":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale Factor: <input type="range" id="${mod.id}_scale" min="0" max="25" step=".001" value="${mod.instance.scaleFactor}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_scale`).addEventListener('input', (e) => {
                        mod.instance.scaleFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "fractalNoise":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale Factor: <input type="range" id="${mod.id}_scaleFactor" min="0" max="200" step="1" value="${mod.instance.scaleFactor}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Octaves: <input type="range" id="${mod.id}_octaves" min="1" max="8" step="1" value="${mod.instance.octaves}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Persistence: <input type="range" id="${mod.id}_persistence" min="0.1" max="1.0" step="0.01" value="${mod.instance.persistence}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => {
                        mod.instance.scaleFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_octaves`).addEventListener('input', (e) => {
                        mod.instance.octaves = parseInt(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_persistence`).addEventListener('input', (e) => {
                        mod.instance.persistence = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "ridgedNoise":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale Factor: <input type="range" id="${mod.id}_scaleFactor" min="0" max="200" step="1" value="${mod.instance.scaleFactor}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => {
                        mod.instance.scaleFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "voronoiNoise":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale Factor: <input type="range" id="${mod.id}_scaleFactor" min="0" max="200" step="0.1" value="${mod.instance.scaleFactor}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Cell Size: <input type="range" id="${mod.id}_cellSize" min="0.01" max="0.2" step="0.01" value="${mod.instance.cellSize}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => {
                        mod.instance.scaleFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_cellSize`).addEventListener('input', (e) => {
                        mod.instance.cellSize = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "torus":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Major Radius (R): <input type="range" id="${mod.id}_R" min="10" max="100" step="0.001" value="${mod.instance.R}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Minor Radius (r): <input type="range" id="${mod.id}_r" min="5" max="50" step="0.001" value="${mod.instance.r}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_R`).addEventListener('input', (e) => {
                        mod.instance.R = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_r`).addEventListener('input', (e) => {
                        mod.instance.r = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "rossler":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Minimum Jitter Factor: <input type="range" id="${mod.id}_jitterFactor" min="0" max=".5" step="0.001" value="${mod.instance.jitterFactor}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_jitterFactor`).addEventListener('input', (e) => {
                        const newVal = parseFloat(e.target.value);
                        mod.instance.jitterFactor = newVal;
                        mod.instance.baseJitterFactor = newVal;
                        saveSettings();
                    });
                    break;

                case "sineDistortion":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Offset X: <input type="range" id="${mod.id}_offsetX" min="-200" max="200" step="1" value="${mod.instance.offsetX}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Offset Y: <input type="range" id="${mod.id}_offsetY" min="-200" max="200" step="1" value="${mod.instance.offsetY}"></label>
                        </div>
                        <div class="controlElement">
                            <label>kDiv: <input type="range" id="${mod.id}_kDiv" min="0" max="50" step="0.001" value="${mod.instance.kDiv}"></label>
                        </div>
                        <div class="controlElement">
                            <label>kSub: <input type="range" id="${mod.id}_kSub" min="0" max="50" step="0.001" value="${mod.instance.kSub}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Scale Factor: <input type="range" id="${mod.id}_scaleFactor" min="0" max="5" step="0.001" value="${mod.instance.scaleFactor}"></label>
                        </div>
                        <div class="controlElement">
                            <label>X Amplitude: <input type="range" id="${mod.id}_xAmplitude" min="0" max="50" step="0.001" value="${mod.instance.xAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Y Amplitude: <input type="range" id="${mod.id}_yAmplitude" min="0" max="50" step="0.001" value="${mod.instance.yAmplitude}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_offsetX`).addEventListener('input', (e) => {
                        mod.instance.offsetX = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_offsetY`).addEventListener('input', (e) => {
                        mod.instance.offsetY = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_kDiv`).addEventListener('input', (e) => {
                        mod.instance.kDiv = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_kSub`).addEventListener('input', (e) => {
                        mod.instance.kSub = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_scaleFactor`).addEventListener('input', (e) => {
                        mod.instance.scaleFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_xAmplitude`).addEventListener('input', (e) => {
                        mod.instance.xAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_yAmplitude`).addEventListener('input', (e) => {
                        mod.instance.yAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "phaseRipple":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Phase Factor: <input type="range" id="${mod.id}_phaseFactor" min="0" max="1" step="0.001" value="${mod.instance.phaseFactor}"></label>
                        </div>
                        <div class="controlElement">
                            <label>X Amplitude: <input type="range" id="${mod.id}_xAmplitude" min="0" max="50" step="0.001" value="${mod.instance.xAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Y Amplitude: <input type="range" id="${mod.id}_yAmplitude" min="0" max="50" step="0.001" value="${mod.instance.yAmplitude}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_phaseFactor`).addEventListener('input', (e) => {
                        mod.instance.phaseFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_xAmplitude`).addEventListener('input', (e) => {
                        mod.instance.xAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_yAmplitude`).addEventListener('input', (e) => {
                        mod.instance.yAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "zSineWarp":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Z Amplitude: <input type="range" id="${mod.id}_zAmplitude" min="0" max="100" step="0.001" value="${mod.instance.zAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Frequency: <input type="range" id="${mod.id}_frequency" min="0" max="5" step="0.001" value="${mod.instance.frequency}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_frequency`).addEventListener('input', (e) => {
                        mod.instance.frequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "radialTwist":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Radial Factor: <input type="range" id="${mod.id}_radialFactor" min="0" max="5" step="0.001" value="${mod.instance.radialFactor}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Twist Factor: <input type="range" id="${mod.id}_twistFactor" min="0" max="10" step="0.001" value="${mod.instance.twistFactor}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Wave Freq: <input type="range" id="${mod.id}_zWaveFrequency" min="0" max="5" step="0.001" value="${mod.instance.zWaveFrequency}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Wave Amp: <input type="range" id="${mod.id}_zWaveAmplitude" min="0" max="50" step="0.001" value="${mod.instance.zWaveAmplitude}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_radialFactor`).addEventListener('input', (e) => {
                        mod.instance.radialFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_twistFactor`).addEventListener('input', (e) => {
                        mod.instance.twistFactor = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zWaveFrequency`).addEventListener('input', (e) => {
                        mod.instance.zWaveFrequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zWaveAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zWaveAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "epicycloid":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Fixed Radius (R): <input type="range" id="${mod.id}_R" min="10" max="150" step="0.1" value="${mod.instance.R}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Rolling Radius (r): <input type="range" id="${mod.id}_r" min="5" max="100" step="0.1" value="${mod.instance.r}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Amplitude: <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Frequency: <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_R`).addEventListener('input', (e) => {
                        mod.instance.R = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_r`).addEventListener('input', (e) => {
                        mod.instance.r = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => {
                        mod.instance.zFrequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "hypocycloid":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Fixed Radius (R): <input type="range" id="${mod.id}_R" min="10" max="150" step="0.1" value="${mod.instance.R}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Rolling Radius (r): <input type="range" id="${mod.id}_r" min="5" max="100" step="0.1" value="${mod.instance.r}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Amplitude: <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Frequency: <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_R`).addEventListener('input', (e) => {
                        mod.instance.R = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_r`).addEventListener('input', (e) => {
                        mod.instance.r = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => {
                        mod.instance.zFrequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "cardioid":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale Factor (a): <input type="range" id="${mod.id}_a" min="10" max="150" step="0.1" value="${mod.instance.a}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Amplitude: <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Frequency: <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => {
                        mod.instance.a = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => {
                        mod.instance.zFrequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "lemniscate":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale Factor (a): <input type="range" id="${mod.id}_a" min="10" max="150" step="0.1" value="${mod.instance.a}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Amplitude: <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Frequency: <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_a`).addEventListener('input', (e) => {
                        mod.instance.a = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => {
                        mod.instance.zFrequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;

                case "butterfly":
                    innerHTML += `
                        <div class="controlElement">
                            <label>Scale: <input type="range" id="${mod.id}_scale" min="10" max="100" step="0.1" value="${mod.instance.scale}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Amplitude: <input type="range" id="${mod.id}_zAmplitude" min="0" max="50" step="0.1" value="${mod.instance.zAmplitude}"></label>
                        </div>
                        <div class="controlElement">
                            <label>Z Frequency: <input type="range" id="${mod.id}_zFrequency" min="0.1" max="5" step="0.1" value="${mod.instance.zFrequency}"></label>
                        </div>
                    `;
                    content.innerHTML = innerHTML;
                    content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
                        mod.instance.speed = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_scale`).addEventListener('input', (e) => {
                        mod.instance.scale = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zAmplitude`).addEventListener('input', (e) => {
                        mod.instance.zAmplitude = parseFloat(e.target.value);
                        saveSettings();
                    });
                    content.querySelector(`#${mod.id}_zFrequency`).addEventListener('input', (e) => {
                        mod.instance.zFrequency = parseFloat(e.target.value);
                        saveSettings();
                    });
                    break;


   case "fluidFlow":
        innerHTML += `
            <div class="controlElement">
                <label>Noise Scale: <input type="range" id="${mod.id}_noiseScale" min="0.01" max="0.2" step="0.01" value="${mod.instance.noiseScale}"></label>
            </div>
            <div class="controlElement">
                <label>Flow Speed: <input type="range" id="${mod.id}_flowSpeed" min="10" max="100" step="1" value="${mod.instance.flowSpeed}"></label>
            </div>
            <div class="controlElement">
                <label>Time Scale: <input type="range" id="${mod.id}_timeScale" min="0.1" max="2.0" step="0.01" value="${mod.instance.timeScale}"></label>
            </div>
            <div class="controlElement">
                <label>Turbulence: <input type="range" id="${mod.id}_turbulence" min="0.1" max="5.0" step="0.1" value="${mod.instance.turbulence}"></label>
            </div>
        `;
        content.innerHTML = innerHTML;
        content.querySelector(`#${mod.id}_speed`)?.addEventListener('input', (e) => {
            mod.instance.speed = parseFloat(e.target.value);
            saveSettings();
        });
        content.querySelector(`#${mod.id}_noiseScale`).addEventListener('input', (e) => {
            mod.instance.noiseScale = parseFloat(e.target.value);
            saveSettings();
        });
        content.querySelector(`#${mod.id}_flowSpeed`).addEventListener('input', (e) => {
            mod.instance.flowSpeed = parseFloat(e.target.value);
            saveSettings();
        });
        content.querySelector(`#${mod.id}_timeScale`).addEventListener('input', (e) => {
            mod.instance.timeScale = parseFloat(e.target.value);
            saveSettings();
        });
        content.querySelector(`#${mod.id}_turbulence`).addEventListener('input', (e) => {
            mod.instance.turbulence = parseFloat(e.target.value);
            saveSettings();
        });
        break;


   }






            const containerId = categoryMap[mod.id] + "Content";
            const container = document.getElementById(containerId);
            if (container) {
                container.appendChild(header);
                container.appendChild(content);
            } else {
                console.error(`Container ${containerId} not found for ${mod.id}`);
            }

            header.addEventListener('click', function(e) {
                if (e.target !== enableCheckbox) {
                    content.style.display = (content.style.display === 'block') ? 'none' : 'block';
                }
            });
        });

        document.getElementById('soundEnable').addEventListener('change', (e) => {
            this.soundModule.enabled = e.target.checked;
            saveSettings();
        });
        document.getElementById('soundSensitivity').addEventListener('input', (e) => {
            this.soundModule.sensitivity = parseFloat(e.target.value);
            saveSettings();
        });
        document.getElementById('soundExpansionFactor').addEventListener('input', saveSettings);
        document.getElementById('startAudio').addEventListener('click', () => {
            this.soundModule.init();
            document.getElementById('startAudio').disabled = true;
        });
        document.querySelectorAll('.moduleHeader[data-target="soundModule"]').forEach(header => {
            header.addEventListener('click', function() {
                const soundContent = document.getElementById('soundModule');
                soundContent.style.display = (soundContent.style.display === 'block') ? 'none' : 'block';
            });
        });



        document.getElementById('soundJitterEnable').addEventListener('change', function(e) {
            if (e.target.checked) {
                if (window.visualization && window.visualization.rossler) {
                    window.visualization.rossler.enabled = true;
                }
                const rosslerCheckbox = document.getElementById('rossler_enable');
                if (rosslerCheckbox) {
                    rosslerCheckbox.checked = true;
                }
            }
        });



        document.getElementById('controlPanel').addEventListener('input', saveSettings);
        document.getElementById('saveFavorite').addEventListener('click', saveFavorite);


    }
}


function captureFavoriteThumbnail() {
  const viz = window.visualization;
  if (!viz || !viz.renderer || !viz.composer) return null;

  const thumbnailSize = 512;
  const canvas = document.createElement('canvas');
  canvas.width = thumbnailSize;
  canvas.height = thumbnailSize;
  const ctx = canvas.getContext('2d');

  // Temporarily disable TAA
  const taaEnabled = viz.taaPass.enabled;
  viz.taaPass.enabled = false;

  // Resize renderer and composer for capture
  const originalWidth = viz.renderer.domElement.width;
  const originalHeight = viz.renderer.domElement.height;
  viz.renderer.setSize(thumbnailSize, thumbnailSize, false);
  viz.composer.setSize(thumbnailSize, thumbnailSize);

  // Clear and render with composer (no TAA)
  viz.renderer.clear();
  viz.composer.render();

  // Capture from the renderer's canvas
  ctx.drawImage(viz.renderer.domElement, 0, 0, thumbnailSize, thumbnailSize);

  // Restore original state
  viz.renderer.setSize(originalWidth, originalHeight, false);
  viz.composer.setSize(originalWidth, originalHeight);
  viz.taaPass.enabled = taaEnabled;

  return canvas.toDataURL('image/png');
}





class Visualization {
    constructor() {
        console.log('Visualization constructor started');
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        this.camera.position.set(0, 0, 300);
        console.log('Camera created:', this.camera);

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        if (this.renderer.getContext().isContextLost()) {
            console.error('WebGL context lost on initialization');
            return;
        }
        this.renderer.toneMapping = THREE.ReinhardToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);
        this.taaPass = new TAARenderPass(this.scene, this.camera, 0x000000);
        this.taaPass.sampleLevel = 10;
        this.taaPass.enabled = true;
        this.composer.addPass(this.taaPass);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.1;
        this.controls.addEventListener('change', () => saveSettings());

        // Equations setup
        this.lissajous = new LissajousEquation();
        this.roseCurve = new RoseCurveEquation();
        this.spiral = new SpiralEquation();
        this.fourierSeries = new FourierSeriesEquation();
        this.shm = new SHMEquation();
        this.reactionDiffusion = new ReactionDiffusionEquation();
        this.noiseEq = new NoiseEquation();
        this.fractalNoise = new FractalNoiseEquation();
        this.ridgedNoise = new RidgedNoiseEquation();
        this.voronoiNoise = new VoronoiNoiseEquation();
        this.torusEq = new TorusEquation();
        this.rossler = new NoiseJitterEquation();
        this.rossler.baseJitterFactor = this.rossler.jitterFactor;
        this.sineDistortion = new SineDistortionEquation();
        this.phaseRipple = new PhaseRippleEquation();
        this.zSineWarp = new ZSineWarpEquation();
        this.radialTwist = new RadialTwistEquation();
        this.epicycloid = new EpicycloidEquation();
        this.hypocycloid = new HypocycloidEquation();
        this.cardioid = new CardioidEquation();
        this.lemniscate = new LemniscateEquation();
        this.butterfly = new ButterflyEquation();
        this.fluidFlow = new FluidFlowEquation();

        // Set initial enabled states
        this.lissajous.enabled = false;
        this.spiral.enabled = false;
        this.fourierSeries.enabled = false;
        this.shm.enabled = false;
        this.reactionDiffusion.enabled = false;
        this.noiseEq.enabled = false;
        this.fractalNoise.enabled = false;
        this.ridgedNoise.enabled = false;
        this.voronoiNoise.enabled = false;
        this.torusEq.enabled = false;
        this.rossler.enabled = false;
        this.sineDistortion.enabled = false;
        this.phaseRipple.enabled = false;
        this.zSineWarp.enabled = false;
        this.radialTwist.enabled = false;
        this.epicycloid.enabled = false;
        this.hypocycloid.enabled = false;
        this.cardioid.enabled = false;
        this.lemniscate.enabled = false;
        this.butterfly.enabled = false;
        this.fluidFlow.enabled = false;

        this.eqModules = [
            { id: "rossler", name: "Rossler Jitter", instance: this.rossler },
            { id: "roseCurve", name: "Rose Curve", instance: this.roseCurve },
            { id: "spiral", name: "Spiral Curve", instance: this.spiral },
            { id: "torus", name: "Torus", instance: this.torusEq },
            { id: "fourierSeries", name: "Fourier Series", instance: this.fourierSeries },
            { id: "lissajous", name: "Lissajous", instance: this.lissajous },
            { id: "epicycloid", name: "Epicycloid", instance: this.epicycloid },
            { id: "hypocycloid", name: "Hypocycloid", instance: this.hypocycloid },
            { id: "cardioid", name: "Cardioid", instance: this.cardioid },
            { id: "lemniscate", name: "Lemniscate", instance: this.lemniscate },
            { id: "butterfly", name: "Butterfly", instance: this.butterfly },
            { id: "sineDistortion", name: "Sine Distortion", instance: this.sineDistortion },
            { id: "reactionDiffusion", name: "Reaction-Diffusion", instance: this.reactionDiffusion },
            { id: "phaseRipple", name: "Phase Ripple", instance: this.phaseRipple },
            { id: "zSineWarp", name: "Z-Sine Warp", instance: this.zSineWarp },
            { id: "radialTwist", name: "Radial Twist", instance: this.radialTwist },
            { id: "shm", name: "Simple Harmonic Motion", instance: this.shm },
            { id: "noiseEq", name: "Simplex Noise", instance: this.noiseEq },
            { id: "fractalNoise", name: "Fractal Noise", instance: this.fractalNoise },
            { id: "ridgedNoise", name: "Ridged Noise", instance: this.ridgedNoise },
            { id: "voronoiNoise", name: "Voronoi Noise", instance: this.voronoiNoise },
            { id: "fluidFlow", name: "Fluid Flow", instance: this.fluidFlow }
        ];

        // Single instantiation with camera
        this.integrationModule = new IntegrationModule(this.scene, this.eqModules, this.camera);
        this.integrationModule.setRenderer(this.renderer);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.1);
        directionalLight.position.set(100, 100, 100);
        this.scene.add(directionalLight);

        this.soundModule = new SoundModule();
        window.addEventListener('resize', this.onWindowResize.bind(this), false);

        this.lastTime = performance.now();
        this.globalTime = 0;
        this.animationFrameId = null;
        this.frameCount = 0;
        this.fpsAccumulator = 0;
        this.lastFpsUpdate = performance.now();

        console.log('Visualization constructor completed');
    }




    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.composer.setSize(window.innerWidth, window.innerHeight);
    }

    restart() {
        console.log('Restart called, camera:', this.camera);
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
        }

        if (!this.renderer || this.renderer.getContext().isContextLost()) {
            console.error('Renderer unavailable or WebGL context lost; recreating');
            this.renderer = new THREE.WebGLRenderer({ antialias: true });


        this.renderer.toneMapping = THREE.ReinhardToneMapping; // Add this
        this.renderer.toneMappingExposure = 1.2;
        //this.renderer.outputEncoding = THREE.sRGBEncoding;


            this.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(this.renderer.domElement);
            this.composer = new EffectComposer(this.renderer);
            const renderPass = new RenderPass(this.scene, this.camera);
            this.composer.addPass(renderPass);
            this.taaPass = new TAARenderPass(this.scene, this.camera, 0x000000);
            this.taaPass.sampleLevel = 10;
            this.taaPass.enabled = document.getElementById('taaEnable')?.checked || false;
            this.composer.addPass(this.taaPass);
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.1;
            this.controls.addEventListener('change', () => saveSettings());
        }

        this.lastTime = performance.now();
        this.globalTime = 0;
        while (this.scene.children.length > 0) {
            this.scene.remove(this.scene.children[0]);
        }

        this.setupScene();
        this.integrationModule.setRenderer(this.renderer);
        const defaultPointCount = parseInt(document.getElementById('globalPointCount')?.value || DEFAULT_POINT_COUNT);
        this.integrationModule.initializeGPU(defaultPointCount);

        this.controls.enabled = true;
        this.controls.update();
        this.animate();
    }

    setupScene() {
        this.scene.background = new THREE.Color(0x000000);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 100, 100);
        this.scene.add(directionalLight);
	
	this.integrationModule = new IntegrationModule(this.scene, this.eqModules, this.camera);


        //this.integrationModule = new IntegrationModule(this.scene, this.eqModules);
    }

    animate() {
        this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

        const currentTime = performance.now();
        let deltaTime = (currentTime - this.lastTime) / 1000;
        if (deltaTime > 0.1) deltaTime = 0.016;

        this.lastTime = currentTime;
        this.globalTime += deltaTime;

        this.frameCount++;
        this.fpsAccumulator += deltaTime;
        if (currentTime - this.lastFpsUpdate >= 1000) {
            const fps = Math.round(this.frameCount / this.fpsAccumulator);
            const fpsDisplay = document.getElementById('fpsDisplay');
            if (fpsDisplay) fpsDisplay.textContent = `FPS: ${fps}`;
            this.frameCount = 0;
            this.fpsAccumulator = 0;
            this.lastFpsUpdate = currentTime;
        }

        if (!this.renderer || this.renderer.getContext().isContextLost()) {
            console.error('Renderer lost during animate; restarting');
            this.restart();
            return;
        }


    // Ensure integrationModule has a camera before updating
    if (!this.integrationModule.camera && !window.visualization?.camera) {
        console.error('No camera available for animate, skipping frame');
        return;
    }



        this.integrationModule.update(deltaTime, this.globalTime);
        this.soundModule.update(deltaTime);

        const jitterEnableEl = document.getElementById('soundJitterEnable');
        if (
            jitterEnableEl && jitterEnableEl.checked &&
            document.getElementById('soundJitterLow') &&
            document.getElementById('soundJitterHigh') &&
            document.getElementById('soundJitterModStrength')
        ) {
            let low = parseInt(document.getElementById('soundJitterLow').value);
            let high = parseInt(document.getElementById('soundJitterHigh').value);
            if (low > high) [low, high] = [high, low];
            let modStrength = parseFloat(document.getElementById('soundJitterModStrength').value);
            let freqData = this.soundModule.frequencyData;
            if (freqData && freqData.length > 0) {
                let maxRatio = 0;
                const maxBin = freqData.length - 1;
                for (let i = low; i <= high && i < freqData.length; i++) {
                    let dB = freqData[i];
                    let ratio = (dB + 100) / 100;
                    ratio = Math.max(0, Math.min(1, ratio));
                    let scaleFactor = 1 + (i / maxBin) * 100;
                    let adjustedRatio = ratio * scaleFactor;
                    if (adjustedRatio > maxRatio) {
                        maxRatio = adjustedRatio;
                    }
                }
                let offset = modStrength * maxRatio;
                let newJitter = this.rossler.baseJitterFactor + offset;
                newJitter = Math.max(0, newJitter);
                this.rossler.jitterFactor = newJitter;
            }
        } else {
            this.rossler.jitterFactor = this.rossler.baseJitterFactor;
        }

        this.controls.update();
        this.renderer.setClearColor(0x000000, 1);
        this.composer.render();
    }

    startAnimation() {
        console.log('Starting animation');
        this.animate();
    }
}

window.addEventListener('focus', () => {
    if (window.visualization) {
        window.visualization.lastTime = performance.now();
        if (window.visualization.soundModule && window.visualization.soundModule.audioContext) {
            const ctx = window.visualization.soundModule.audioContext;
            if (ctx.state === "suspended") {
                ctx.resume();
            }
        }
    }
});


/**************** Main Initialization ****************/
console.log('Script loaded, electronAPI available:', !!window.electronAPI);

function initializeApp() {
    console.log('initializeApp called');
    try {
        const viz = new Visualization();
        window.visualization = viz;
        console.log('Visualization instance created');

        // Step 1: Instantiate ControlPanel first to set up the DOM and listeners
        new ControlPanel(viz.eqModules, viz.soundModule);
        console.log('ControlPanel initialized');

        // Step 2: Load settings after ControlPanel is ready
        loadSettings().then(() => {
            console.log('Settings loaded successfully');
            const pointCount = parseInt(document.getElementById('globalPointCount').value || DEFAULT_POINT_COUNT);
            console.log('Initializing GPU with pointCount:', pointCount);
            viz.integrationModule.initializeGPU(pointCount);
            console.log('Initial setup complete with pointCount:', pointCount);




            // viz.startAnimation(); // Start animation here

	    // Delay startAnimation to ensure all setup completes
            setTimeout(() => {
                viz.startAnimation();
                console.log('Animation started');
            }, 100); // Small delay to avoid race conditions




            syncJitterAndRossler();
            document.getElementById('soundJitterEnable').addEventListener('change', syncJitterAndRossler);

            const controlPanel = document.getElementById('controlPanel');
            if (controlPanel) {
                controlPanel.style.transform = "translateX(0)";
                controlPanel.style.opacity = "1";
                setTimeout(() => {
                    controlPanel.style.removeProperty('transform');
                    controlPanel.style.removeProperty('opacity');
                }, 3000);
            } else {
                console.warn('Control panel element not found');
            }

            viz.soundModule.init();
            document.getElementById('startAudio').disabled = true;

            setTimeout(() => {
                window.electronAPI.loadFavorites().then(favorites => {
                    if (!favorites || favorites.length === 0) {
                        console.log("No favorites to update at startup");
                        updateFavoriteList();
                        return;
                    }
                    console.log(`Checking ${favorites.length} favorites for missing thumbnails`);
                    const needsThumbnails = favorites.some(fav => !fav.thumbnail);
                    const messageElement = document.getElementById('thumbnailCaptureMessage');
                    let thumbnailsUpdated = false;

                    if (needsThumbnails) {
                        messageElement.style.display = 'block';
                    }

                    const generateThumbnailForFavorite = (fav, index) => {
                        return new Promise(resolve => {
                            console.log(`Loading settings for Favorite ${index + 1}`);
                            loadFavoriteForSlideshow(fav);
                            const viz = window.visualization;
                            const deltaTime = 0.016;
                            const simulationFrames = 20;
                            let frameCount = 0;

                            setTimeout(() => {
                                const originalAnimate = viz.animate;
                                viz.animate = function animateWithCapture() {
                                    viz.animationFrameId = requestAnimationFrame(animateWithCapture);
                                    const currentTime = performance.now();
                                    viz.lastTime = currentTime - deltaTime * 1000;
                                    viz.globalTime += deltaTime;

                                    viz.integrationModule.update(deltaTime, viz.globalTime);
                                    viz.soundModule.update(deltaTime);
                                    viz.controls.update();

                                    frameCount++;
                                    if (frameCount >= simulationFrames) {
                                        cancelAnimationFrame(viz.animationFrameId);
                                        const thumbnail = captureFavoriteThumbnail();
                                        if (!thumbnail) {
                                            console.warn(`Failed to generate thumbnail for Favorite ${index + 1}`);
                                        } else {
                                            console.log(`Thumbnail generated for Favorite ${index + 1}:`, thumbnail.substring(0, 50));
                                            fav.thumbnail = thumbnail;
                                            thumbnailsUpdated = true;
                                        }
                                        viz.animate = originalAnimate;
                                        viz.animate();
                                        resolve();
                                    }
                                    viz.composer.render();
                                };
                                viz.animate();
                            }, 1100);
                        });
                    };

                    const processFavorites = async () => {
                        for (let i = 0; i < favorites.length; i++) {
                            if (!favorites[i].thumbnail) {
                                await generateThumbnailForFavorite(favorites[i], i);
                            }
                        }
                        if (thumbnailsUpdated) {
                            console.log("Saving updated favorites with new thumbnails:", favorites);
                            await window.electronAPI.saveFavorites(favorites).then(result => {
                                if (result.success) {
                                    console.log("Favorites updated successfully with thumbnails");
                                } else {
                                    console.error("Failed to save updated favorites:", result.error);
                                }
                            });
                            console.log("Requesting app restart after thumbnail generation...");
                            window.electronAPI.restartApp();
                        } else {
                            console.log("No thumbnails needed updating");
                        }
                        updateFavoriteList(); // Update the favorite list once processing is complete
                        messageElement.style.display = 'none';
                    };

                    processFavorites();
                }).catch(err => {
                    console.error("Error loading favorites at startup:", err);
                    document.getElementById('thumbnailCaptureMessage').style.display = 'none';
                });
            }, 2000);
        }).catch(err => {
            console.error('Error during settings load or initialization:', err);
        });
    } catch (err) {
        console.error('Synchronous error in initializeApp:', err);
    }
}





document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded event fired');
    try {
        initializeApp();
    } catch (err) {
        console.error('Synchronous error in DOMContentLoaded:', err);
    }
});

setTimeout(() => {
    if (!window.visualization) {
        console.log('DOMContentLoaded fallback triggered');
        initializeApp();
    }
}, 1000);









function loadSettings() {
  console.log('Starting loadSettings');
  if (!window.electronAPI || typeof window.electronAPI.loadSettings !== 'function') {
    console.error('electronAPI.loadSettings is not available');
    return Promise.reject(new Error('electronAPI not initialized'));
  }
  return window.electronAPI.loadSettings().then(settings => {
    if (settings) {
      // **Temporarily disable saveSettings to prevent unwanted saves**
      const originalSaveSettings = window.saveSettings;
      window.saveSettings = () => console.log('saveSettings: Suppressed during load');

      // **Restore control panel settings with event dispatching**
      for (const id in settings) {
        if (id === "camera" || id === "fullscreenToggle" || id === "visualization") continue;
        const element = document.getElementById(id);
        if (element) {
          if (element.type === "checkbox") {
            element.checked = settings[id];
            element.dispatchEvent(new Event('change', { bubbles: true }));
          } else {
            element.value = settings[id];
            element.dispatchEvent(new Event('input', { bubbles: true }));
          }
        } else {
          console.warn(`Element with id "${id}" not found in DOM`);
        }
      }

      // **Restore camera settings**
      if (settings.camera && window.visualization) {
        const cam = settings.camera;
        window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
        window.visualization.camera.zoom = cam.zoom;
        window.visualization.camera.updateProjectionMatrix();
        window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
        window.visualization.controls.update();
      }

      // **Restore equation internal states**
      if (settings.visualization && settings.visualization.equations && window.visualization) {
        const { equations } = settings.visualization;
        window.visualization.eqModules.forEach(mod => {
          if (equations[mod.id]) {
            mod.instance.deserializeState(equations[mod.id]);
          }
        });
      }

      // **Re-enable saveSettings**
      window.saveSettings = originalSaveSettings;
      console.log('loadSettings completed');
    }
  }).catch(err => {
    console.error('loadSettings failed:', err);
    throw err;
  });
}









function syncJitterAndRossler() {
    const jitterCheckbox = document.getElementById('soundJitterEnable');
    if (jitterCheckbox && jitterCheckbox.checked) {
        if (window.visualization && window.visualization.rossler && !window.visualization.rossler.enabled) {
            window.visualization.rossler.enabled = true;
            const rosslerCheckbox = document.getElementById('rossler_enable');
            if (rosslerCheckbox) {
                rosslerCheckbox.checked = true;
            }
        }
    }
}

document.body.classList.add('hide-cursor');
const controlPanel = document.getElementById('controlPanel');
controlPanel.addEventListener('mouseenter', () => {
    document.body.classList.remove('hide-cursor');
});
controlPanel.addEventListener('mouseleave', () => {
    document.body.classList.add('hide-cursor');
});

/**************** End Main Initialization ****************/</script>





  <!-- ===================================================================== -->
  <!-- ============== SINGLE CHECKBOX WAKE LOCK INTEGRATION ================= -->
  <!-- ===================================================================== -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const screenStaysActive = document.getElementById('screenStaysActive');
      let wakeLock = null;
      const requestWakeLock = async () => {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (err) {
          console.error(`Wake lock request failed: ${err.name}, ${err.message}`);
        }
      };
      const releaseWakeLock = async () => {
        if (wakeLock !== null) {
          try {
            await wakeLock.release();
            wakeLock = null;
          } catch (err) {
            console.error(`Wake lock release failed: ${err.name}, ${err.message}`);
          }
        }
      };
      const handleVisibilityChange = async () => {
        if (screenStaysActive.checked && document.visibilityState === 'visible') {
          await requestWakeLock();
        }
      };
      screenStaysActive.addEventListener('change', async () => {
        if (screenStaysActive.checked) {
          await requestWakeLock();
          document.addEventListener('visibilitychange', handleVisibilityChange);
        } else {
          await releaseWakeLock();
          document.removeEventListener('visibilitychange', handleVisibilityChange);
        }
      });
    });
  </script>
  <!-- ===================================================================== -->

  <!-- New Script: Slideshow of Favorites -->







<script>
  document.addEventListener('DOMContentLoaded', () => {
    let slideshowTimer = null;
    let slideshowActive = false;
    let slideshowIndex = 0;
    let slideshowFavorites = [];
    let modalTimeout = null;

    function loadFavoriteForSlideshow(fav) {
      document.body.style.transition = "opacity 0.5s ease";
      document.body.style.opacity = "0";
      setTimeout(() => {
        for (const id in fav) {
          if (id === "camera" || id === "fullscreenToggle" || id === "slideshowRandom" || id === "slideshowInterval") continue;
          const element = document.getElementById(id);
          if (element) {
            if (element.type === "checkbox") {
              element.checked = fav[id];
              element.dispatchEvent(new Event('change'));
            } else {
              element.value = fav[id];
              element.dispatchEvent(new Event('input'));
            }
          }
        }
        if (fav.camera && window.visualization) {
          const cam = fav.camera;
          window.visualization.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
          window.visualization.camera.zoom = cam.zoom;
          window.visualization.camera.updateProjectionMatrix();
          window.visualization.controls.target.set(cam.controlsTarget.x, cam.controlsTarget.y, cam.controlsTarget.z);
          window.visualization.controls.update();
        }
        if (window.visualization && window.visualization.eqModules && fav.equations) {
          window.visualization.eqModules.forEach(mod => {
            if (fav.equations[mod.id] !== undefined) {
              mod.instance.deserializeState(fav.equations[mod.id]);
            }
          });
        }
        saveSettings();
        document.body.style.opacity = "1";
      }, 500);
    }

    async function nextSlideshow() {
      if (!slideshowActive) return;
      let favorites = await window.electronAPI.loadFavorites();
      slideshowFavorites = favorites || [];
      if (slideshowFavorites.length === 0) {
        cancelSlideshow();
        return;
      }
      if (document.getElementById('slideshowRandom').checked) {
        slideshowIndex = Math.floor(Math.random() * slideshowFavorites.length);
      } else {
        slideshowIndex = (slideshowIndex + 1) % slideshowFavorites.length;
      }
      loadFavoriteForSlideshow(slideshowFavorites[slideshowIndex]);
      const intervalMinutes = parseInt(document.getElementById('slideshowInterval').value, 10);
      const intervalMs = intervalMinutes * 60 * 1000;
      slideshowTimer = setTimeout(nextSlideshow, intervalMs);
    }

    function showExitModal() {
      if (!slideshowActive) return;
      const modal = document.getElementById('slideshowExitModal');
      modal.style.display = 'block';
      // NEW: Show the cursor when the modal appears
      document.body.style.cursor = "auto";
      let countdown = 4;
      document.getElementById('countdownTimer').textContent = `Closing in ${countdown}s`;

      modalTimeout = setInterval(() => {
        countdown--;
        document.getElementById('countdownTimer').textContent = `Closing in ${countdown}s`;
        if (countdown <= 0) {
          closeModal(false);
        }
      }, 1000);

  
/*
    const exitYes = document.getElementById('exitSlideshowYes');
      const exitNo = document.getElementById('exitSlideshowNo');
      const newExitYes = exitYes.cloneNode(true);
      const newExitNo = exitNo.cloneNode(true);
      exitYes.parentNode.replaceChild(newExitYes, exitYes);
      exitNo.parentNode.replaceChild(newExitNo, exitNo);

      newExitYes.addEventListener('click', () => closeModal(true));
      newExitNo.addEventListener('click', () => closeModal(false));
*/

const exitYes = document.getElementById('exitSlideshowYes');
  exitYes.onclick = null; // [ADDED] Remove any existing onclick handler
  exitYes.addEventListener('click', () => closeModal(true)); // [ADDED] Add new listener

    }

    function closeModal(exit) {
      const modal = document.getElementById('slideshowExitModal');
      modal.style.display = 'none';
      // NEW: Hide the cursor again if the slideshow continues
      if (slideshowActive) {
        document.body.style.cursor = "none";
      }
      clearInterval(modalTimeout);
      modalTimeout = null;
      if (exit) {
        cancelSlideshow();
      }
      if (slideshowActive) {
        document.addEventListener('click', clickHandler);
      }
    }

    function clickHandler(e) {
      if (slideshowActive) {
        e.stopPropagation();
        document.removeEventListener('click', clickHandler);
        showExitModal();
      }
    }

    async function startSlideshow() {
      const fullscreenToggle = document.getElementById("fullscreenToggle");
      if (fullscreenToggle) {
        if (fullscreenToggle.checked === true) {
          fullscreenToggle.checked = false;
          fullscreenToggle.dispatchEvent(new Event("change"));
          setTimeout(() => {
            fullscreenToggle.checked = true;
            fullscreenToggle.dispatchEvent(new Event("change"));
          }, 150);
        } else {
          fullscreenToggle.checked = true;
          fullscreenToggle.dispatchEvent(new Event("change"));
        }
      }

      const screenStaysActive = document.getElementById("screenStaysActive");
      if (screenStaysActive) {
        if (screenStaysActive.checked === true) {
          screenStaysActive.checked = false;
          screenStaysActive.dispatchEvent(new Event("change"));
          setTimeout(() => {
            screenStaysActive.checked = true;
            screenStaysActive.dispatchEvent(new Event("change"));
          }, 150);
        } else {
          screenStaysActive.checked = true;
          fullscreenToggle.dispatchEvent(new Event("change"));
        }
      }

      let favorites = await window.electronAPI.loadFavorites();
      slideshowFavorites = favorites || [];
      if (slideshowFavorites.length === 0) {
        alert("No favorites available for slideshow.");
        return;
      }
      slideshowActive = true;
      slideshowIndex = -1;
      nextSlideshow();
      const slideshowButton = document.getElementById('startSlideshow');
      slideshowButton.style.pointerEvents = "none";
      setTimeout(() => { slideshowButton.style.pointerEvents = ""; }, 2000);
      document.getElementById("controlPanel").style.display = "none";
      document.body.style.cursor = "none";
      document.addEventListener('click', clickHandler);
    }

    function cancelSlideshow() {
      slideshowActive = false;
      if (slideshowTimer) {
        clearTimeout(slideshowTimer);
        slideshowTimer = null;
      }
      if (modalTimeout) {
        clearInterval(modalTimeout);
        modalTimeout = null;
        document.getElementById('slideshowExitModal').style.display = 'none';
      }
      document.removeEventListener('click', clickHandler);
      document.getElementById('startSlideshow').textContent = "SLIDESHOW";
      document.getElementById("controlPanel").style.display = "";
      document.body.style.cursor = ""; // Reset to default when slideshow ends
    }

    const slideshowButton = document.getElementById('startSlideshow');
    slideshowButton.addEventListener('click', () => {
      if (!slideshowActive) {
        startSlideshow();
        slideshowButton.textContent = "SLIDESHOW (Active)";
      } else {
        cancelSlideshow();
        slideshowButton.textContent = "SLIDESHOW";
      }
    });
  });
</script>







  <!-- New Script: Attach Favorites Roll-down Button Listener -->
  <script>
    const toggleButton = document.getElementById('toggleFavoriteList');
    const favoriteListContainer = document.getElementById('favoriteListContainer');
    if (toggleButton && favoriteListContainer) {
      toggleButton.addEventListener('click', () => {
        favoriteListContainer.classList.toggle('open');
      });
    }
  </script>

<!-- New Script: Export/Import Favorites -->
<script>


  // Export Favorites using the electronAPI-loaded data.
  document.getElementById('exportFavorites').addEventListener('click', function(){
    window.electronAPI.loadFavorites().then(favorites => {
      if(!favorites || favorites.length === 0){
        document.getElementById('exportStatusText').textContent =
          "No favorites to export (" + new Date().toLocaleTimeString() + ")";
        return;
      }
      let blob = new Blob([JSON.stringify(favorites)], { type: "application/json" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = "PuLsE-favs.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      document.getElementById('exportStatusText').textContent =
        "Exported at " + new Date().toLocaleTimeString();
    });
  });





  // Import Favorites: Read a JSON file and merge with the existing favorites.
  document.getElementById('importFavorites').addEventListener('click', function(){
    document.getElementById('importFavoritesInput').click();
  });

  document.getElementById('importFavoritesInput').addEventListener('change', function(event){
    let file = event.target.files[0];
    if (!file) return;
    if (!file.name.toLowerCase().endsWith(".json")){
      document.getElementById('importStatusText').textContent =
        "Select a valid .json file (" + new Date().toLocaleTimeString() + ")";
      event.target.value = "";
      return;
    }
    let reader = new FileReader();
    reader.onload = function(e){
      try {
        let importedFavorites = JSON.parse(e.target.result);
        if (!Array.isArray(importedFavorites)){
          document.getElementById('importStatusText').textContent =
            "Invalid file content (" + new Date().toLocaleTimeString() + ")";
          return;
        }
        window.electronAPI.loadFavorites().then(currentFavorites => {
          if(!Array.isArray(currentFavorites)) currentFavorites = [];
          let mergedFavorites = currentFavorites.concat(importedFavorites);
          window.electronAPI.saveFavorites(mergedFavorites).then(result=>{
            updateFavoriteList();
            document.getElementById('importStatusText').textContent =
              "Imported at " + new Date().toLocaleTimeString();
          });
        });
      } catch (err) {
        document.getElementById('importStatusText').textContent =
          "Error reading file (" + new Date().toLocaleTimeString() + ")";
      }
    };
    reader.readAsText(file);
    event.target.value = "";
  });



</script>


<!-- New Script: Attach data-target event listeners to category roll-down headers -->
<script> 
// Now only attach the toggle handler to the category headers within #eqModules.
document.querySelectorAll('#eqModules > div > .moduleHeader[data-target]').forEach(header => {
  header.addEventListener('click', function(){
    const targetId = header.getAttribute('data-target');
    const contentDiv = document.getElementById(targetId);
    contentDiv.style.display = (contentDiv.style.display === 'block') ? 'none' : 'block';
  });
});
</script>



<script>
  let wasBlurred = false;
  window.addEventListener('blur', () => {
    wasBlurred = true;
  });
  window.addEventListener('focus', () => {
    if (wasBlurred) {
      console.log("Window was blurred; restarting visualization.");
      wasBlurred = false;
      if (window.visualization) {
        window.visualization.restart();
      }
    }
  });
</script>


<script>
// Sync checkbox with fullscreen state changes
  document.addEventListener('fullscreenchange', () => {
    fullscreenToggle.checked = !!document.fullscreenElement;
    saveSettings(); // Optional: Save settings when state changes
  });
</script>


<script>
document.addEventListener('DOMContentLoaded', () => {
    try {
        const aboutButton = document.getElementById('aboutButton');
        const aboutModal = document.getElementById('aboutModal');
        const closeAbout = document.getElementById('closeAbout');

        if (!aboutButton) { console.error('About button not found'); return; }
        if (!aboutModal) { console.error('About modal not found'); return; }
        if (!closeAbout) { console.error('Close button not found'); return; }

        console.log('Attaching About modal event listeners');

        aboutButton.addEventListener('click', () => {
            console.log('About button clicked');
            aboutModal.style.display = 'block';
            document.body.style.cursor = 'auto'; // Show cursor when modal opens
        });

        closeAbout.addEventListener('click', () => {
            console.log('Close button clicked');
            aboutModal.style.display = 'none';
            document.body.style.cursor = 'none'; // Hide cursor when modal closes
        });

        aboutModal.addEventListener('click', (e) => {
            if (e.target === aboutModal) {
                console.log('Clicked outside modal content');
                aboutModal.style.display = 'none';
                document.body.style.cursor = 'none'; // Hide cursor when modal closes
            }
        });
    } catch (err) {
        console.error('Error in About modal setup:', err);
    }
});
</script>








<!-- Help Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content">
    <span class="close">×</span>
    <h1>PuLsE Help</h1>

    <!-- PuLsE Globals Section -->
    <div class="section">
      <h2>PuLsE Globals</h2>
      <div class="content">
        <ul>
          <li><strong>Fullscreen Toggle</strong>: Check to switch to full screen; uncheck for windowed mode.</li>
          <li><strong>About PuLsE Button</strong>: Opens a modal with PuLsE info (version 11.3.1, creator Patrick G. Leamy). Click "OK" or outside to close.</li>
          <li><strong>Screen Stays Active</strong>: Check to keep your screen from turning off during use.</li>
          <li><strong>Point Count Slider</strong>: Range 10,000 to 1,000,000. Sets the number of glowing dots (e.g., "40,000 pts").</li>
          <li><strong>Disk Size Slider</strong>: Range 0.1 to 2.5. Adjusts dot size.</li>
          <li><strong>Global Speed Slider</strong>: Range -3 to 3. Sets animation speed (e.g., "Global Speed 1.00").</li>
          <li><strong>Enable TAA</strong>: Check to enable Temporal Anti-Aliasing for smoother visuals.</li>
          <li><strong>TAA Quality Slider</strong>: Range 0 to 10. Adjusts TAA smoothness (if enabled).</li>
          <li><strong>Global Color (Hue) Slider</strong>: Range 0 to 360. Sets base color hue (e.g., 0 = red, 120 = green, 240 = blue).</li>
        </ul>
        <h3>Glow Points Settings</h3>
        <p>These sliders let you customize how the glowing dots look. Each "Stop" has a Position slider (0 to 1) to set where the glow changes, and an Alpha slider (0 to 2) to set how bright or transparent it is at that point.</p>
        <ul>
          <li><strong>Stop 1 Position</strong>: Sets the starting point of the glow fade (0 = center, 1 = edge).</li>
          <li><strong>Stop 1 Alpha</strong>: Sets the brightness at the starting point.</li>
          <li><strong>Stop 2 Position</strong>: Sets a second fade point.</li>
          <li><strong>Stop 2 Alpha</strong>: Sets the brightness at the second point.</li>
          <li><strong>Stop 3 Position</strong>: Sets a third fade point.</li>
          <li><strong>Stop 3 Alpha</strong>: Sets the brightness at the third point.</li>
          <li><strong>Stop 4 Position</strong>: Sets the final fade point (usually the edge).</li>
          <li><strong>Stop 4 Alpha</strong>: Sets the brightness at the edge.</li>
        </ul>
        <h3>Favorites</h3>
        <p>Use these buttons to save your favorite settings, see a list of saved favorites, back them up to a file, or import them from a file.</p>
        <ul>
          <li><strong>Save Favorite</strong>: Saves your current settings as a favorite, with a small picture of what it looks like.</li>
          <li><strong>FAVORITES ...</strong>: Click to show or hide the list of your saved favorites.</li>
          <li><strong>Favorites List</strong>: Shows each favorite with options to Load (use it), Export (save it to a file), or Delete (remove it).</li>
          <li><strong>BACKUP</strong>: Saves all your favorites into one file (e.g., "PuLsE-favs.json").</li>
          <li><strong>IMPORT</strong>: Lets you add favorites from a saved file.</li>
        </ul>
        <h3>Slideshow</h3>
        <p>The Slideshow feature lets you automatically cycle through your saved favorites, creating a dynamic visual experience. Here’s how to use it:</p>
        <ul>
          <li><strong>SLIDESHOW Button</strong>: Click to start or stop the slideshow. When active, it hides the Control Panel and goes full screen.</li>
          <li><strong>Random Checkbox</strong>: Check to cycle through favorites in a random order; uncheck for sequential order.</li>
          <li><strong>Interval Input</strong>: Set the time (in minutes) each favorite stays on screen before switching (range: 1 to 30 minutes).</li>
          <li><strong>Instructions</strong>: "Click Anywhere to Disable" — shows how to exit the slideshow.</li>
        </ul>
        <p>To exit the slideshow, click anywhere on the screen. A pop-up will appear asking you to confirm with the "EXIT" button.</p>
      </div>
    </div>

    <!-- Sound Module Section -->
    <div class="section">
      <h2>Sound Module</h2>
      <div class="content">
        <ul>
          <li><strong>Enable Sound Input</strong>: Check to listen to audio (e.g., via "Stereo Mix").</li>
          <li><strong>Sensitivity Slider</strong>: Range 0 to 0.6. Sets reaction to sound volume.</li>
          <li><strong>Emissive Intensity Modulation</strong>: Check to make dots glow brighter with sound.</li>
          <li><strong>Disk Scale Expansion</strong>: Check to make dots larger with sound.</li>
          <li><strong>Expansion Factor Slider</strong>: Range 0 to 15. Sets dot expansion amount.</li>
          <li><strong>Jitter (*enables Rossler)</strong>: Check to add bouncy motion with sound (enables Rossler Jitter).</li>
          <li><strong>Jitter Low Range Slider</strong>: Range 50 to 160. Sets low frequencies for jitter.</li>
          <li><strong>Jitter High Range Slider</strong>: Range 161 to 260. Sets high frequencies for jitter.</li>
          <li><strong>Jitter Modulation Strength Slider</strong>: Range 0 to 1.7. Sets jitter strength.</li>
          <li><strong>Start Audio Button</strong>: Click to start listening (disables after use; restart PuLsE to reset).</li>
          <li><strong>Sound Status</strong>: Shows audio status (e.g., "Audio running...").</li>
        </ul>
      </div>
    </div>

    <!-- Paths Section -->
    <div class="section">
      <h2>Paths</h2>
      <div class="content">
        <ul>
          <li><strong>Rossler Jitter</strong>: Check to enable twisty, jiggly motion.
            <ul>
              <li><strong>Minimum Jitter Factor Slider</strong>: Range 0 to 0.5. Sets base jiggle.</li>
            </ul>
          </li>
          <li><strong>Rose Curve</strong>: Check to enable flower-like petals.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets pattern speed.</li>
              <li><strong>A Slider</strong>: Range 10 to 200. Sets petal size.</li>
              <li><strong>k Slider</strong>: Range 1 to 10. Sets petal count.</li>
            </ul>
          </li>
          <li><strong>Spiral Curve</strong>: Check to enable spinning spiral.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets spin speed.</li>
              <li><strong>a Slider</strong>: Range 0 to 20. Sets starting size.</li>
              <li><strong>b Slider</strong>: Range 0 to 20. Sets growth rate.</li>
            </ul>
          </li>
          <li><strong>Torus</strong>: Check to enable donut-shaped ring.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets rotation speed.</li>
              <li><strong>Major Radius (R) Slider</strong>: Range 10 to 100. Sets donut size.</li>
              <li><strong>Minor Radius (r) Slider</strong>: Range 5 to 50. Sets ring thickness.</li>
            </ul>
          </li>
          <li><strong>Fourier Series</strong>: Check to enable wavy patterns.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets wave speed.</li>
              <li><strong>Amplitude Factor Slider</strong>: Range 5 to 50. Sets wave height.</li>
              <li><strong>Number of Terms Slider</strong>: Range 1 to 20. Sets wave complexity.</li>
            </ul>
          </li>
          <li><strong>Lissajous</strong>: Check to enable smooth looping curves.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets movement speed.</li>
              <li><strong>A Slider</strong>: Range 10 to 100. Sets horizontal stretch.</li>
              <li><strong>B Slider</strong>: Range 10 to 100. Sets vertical stretch.</li>
              <li><strong>a Slider</strong>: Range 1 to 10. Sets horizontal speed.</li>
              <li><strong>b Slider</strong>: Range 1 to 10. Sets vertical speed.</li>
              <li><strong>δ Slider</strong>: Range 0 to 6.28. Sets phase shift.</li>
            </ul>
          </li>
          <li><strong>Epicycloid</strong>: Check to enable spiky star pattern.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets spin speed.</li>
              <li><strong>Fixed Radius (R) Slider</strong>: Range 10 to 150. Sets base circle size.</li>
              <li><strong>Rolling Radius (r) Slider</strong>: Range 5 to 100. Sets rolling circle size.</li>
              <li><strong>Z Amplitude Slider</strong>: Range 0 to 50. Sets depth effect.</li>
              <li><strong>Z Frequency Slider</strong>: Range 0.1 to 5. Sets depth speed.</li>
            </ul>
          </li>
          <li><strong>Hypocycloid</strong>: Check to enable star pattern inside circle.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets spin speed.</li>
              <li><strong>Fixed Radius (R) Slider</strong>: Range 10 to 150. Sets outer circle size.</li>
              <li><strong>Rolling Radius (r) Slider</strong>: Range 5 to 100. Sets rolling circle size.</li>
              <li><strong>Z Amplitude Slider</strong>: Range 0 to 50. Sets depth effect.</li>
              <li><strong>Z Frequency Slider</strong>: Range 0.1 to 5. Sets depth speed.</li>
            </ul>
          </li>
          <li><strong>Cardioid</strong>: Check to enable heart-shaped pattern.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets movement speed.</li>
              <li><strong>Scale Factor (a) Slider</strong>: Range 10 to 150. Sets heart size.</li>
              <li><strong>Z Amplitude Slider</strong>: Range 0 to 50. Sets depth effect.</li>
              <li><strong>Z Frequency Slider</strong>: Range 0.1 to 5. Sets depth speed.</li>
            </ul>
          </li>
          <li><strong>Lemniscate</strong>: Check to enable figure-eight loop.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets loop speed.</li>
              <li><strong>Scale Factor (a) Slider</strong>: Range 10 to 150. Sets loop size.</li>
              <li><strong>Z Amplitude Slider</strong>: Range 0 to 50. Sets depth effect.</li>
              <li><strong>Z Frequency Slider</strong>: Range 0.1 to 5. Sets depth speed.</li>
            </ul>
          </li>
          <li><strong>Butterfly</strong>: Check to enable butterfly-wing pattern.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets flutter speed.</li>
              <li><strong>Scale Slider</strong>: Range 10 to 100. Sets wing size.</li>
              <li><strong>Z Amplitude Slider</strong>: Range 0 to 50. Sets depth effect.</li>
              <li><strong>Z Frequency Slider</strong>: Range 0.1 to 5. Sets depth speed.</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <!-- Distortions Section -->
    <div class="section">
      <h2>Distortions</h2>
      <div class="content">
        <ul>
          <li><strong>Sine Distortion</strong>: Check to enable wavy ripple effect.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets wave speed.</li>
              <li><strong>Offset X Slider</strong>: Range -200 to 200. Sets horizontal shift.</li>
              <li><strong>Offset Y Slider</strong>: Range -200 to 200. Sets vertical shift.</li>
              <li><strong>kDiv Slider</strong>: Range 0 to 50. Sets number of waves.</li>
              <li><strong>kSub Slider</strong>: Range 0 to 50. Sets wave alignment.</li>
              <li><strong>Scale Factor Slider</strong>: Range 0 to 5. Sets wave size.</li>
              <li><strong>X Amplitude Slider</strong>: Range 0 to 50. Sets horizontal strength.</li>
              <li><strong>Y Amplitude Slider</strong>: Range 0 to 50. Sets vertical strength.</li>
            </ul>
          </li>
          <li><strong>Reaction-Diffusion</strong>: Check to enable organic growing patterns.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets growth speed.</li>
              <li><strong>F Slider</strong>: Range 0.01 to 0.1. Sets formation rate.</li>
              <li><strong>k Slider</strong>: Range 0.01 to 0.1. Sets fade rate.</li>
            </ul>
          </li>
          <li><strong>Phase Ripple</strong>: Check to enable shimmering effect.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets shimmer speed.</li>
              <li><strong>Phase Factor Slider</strong>: Range 0 to 1. Sets shimmer movement.</li>
              <li><strong>X Amplitude Slider</strong>: Range 0 to 50. Sets horizontal strength.</li>
              <li><strong>Y Amplitude Slider</strong>: Range 0 to 50. Sets vertical strength.</li>
            </ul>
          </li>
          <li><strong>Z-Sine Warp</strong>: Check to enable 3D bobbing effect.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets bobbing speed.</li>
              <li><strong>Z Amplitude Slider</strong>: Range 0 to 100. Sets bobbing height.</li>
              <li><strong>Frequency Slider</strong>: Range 0 to 5. Sets bobbing frequency.</li>
            </ul>
          </li>
          <li><strong>Radial Twist</strong>: Check to enable central twirl effect.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets twirl speed.</li>
              <li><strong>Radial Factor Slider</strong>: Range 0 to 5. Sets spin tightness.</li>
              <li><strong>Twist Factor Slider</strong>: Range 0 to 10. Sets twist strength.</li>
              <li><strong>Z Wave Frequency Slider</strong>: Range 0 to 5. Sets depth speed.</li>
              <li><strong>Z Wave Amplitude Slider</strong>: Range 0 to 50. Sets depth amount.</li>
            </ul>
          </li>
          <li><strong>Simple Harmonic Motion</strong>: Check to enable bouncy motion.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets bounce speed.</li>
              <li><strong>A Slider</strong>: Range 10 to 100. Sets bounce size.</li>
              <li><strong>ω Slider</strong>: Range 0.5 to 5. Sets bounce frequency.</li>
              <li><strong>ϕ Slider</strong>: Range 0 to 6.28. Sets bounce phase.</li>
            </ul>
          </li>
          <li><strong>Fluid Flow</strong>: Check to enable liquid-like flow.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets flow speed.</li>
              <li><strong>Noise Scale Slider</strong>: Range 0.01 to 0.2. Sets pattern size.</li>
              <li><strong>Flow Speed Slider</strong>: Range 10 to 100. Sets movement speed.</li>
              <li><strong>Time Scale Slider</strong>: Range 0.1 to 2. Sets time effect.</li>
              <li><strong>Turbulence Slider</strong>: Range 0.1 to 5. Sets flow chaos.</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <!-- Noises Section -->
    <div class="section">
      <h2>Noises</h2>
      <div class="content">
        <ul>
          <li><strong>Simplex Noise</strong>: Check to enable soft cloudy texture.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets texture shift speed.</li>
              <li><strong>Scale Factor Slider</strong>: Range 0 to 25. Sets cloud size.</li>
            </ul>
          </li>
          <li><strong>Fractal Noise</strong>: Check to enable bumpy layered texture.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets texture shift speed.</li>
              <li><strong>Scale Factor Slider</strong>: Range 0 to 200. Sets bump size.</li>
              <li><strong>Octaves Slider</strong>: Range 1 to 8. Sets number of layers.</li>
              <li><strong>Persistence Slider</strong>: Range 0.1 to 1. Sets layer strength.</li>
            </ul>
          </li>
          <li><strong>Ridged Noise</strong>: Check to enable sharp ridge texture.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets texture shift speed.</li>
              <li><strong>Scale Factor Slider</strong>: Range 0 to 200. Sets ridge size.</li>
            </ul>
          </li>
          <li><strong>Voronoi Noise</strong>: Check to enable cracked cell pattern.
            <ul>
              <li><strong>Speed Slider</strong>: Range 0 to 3. Sets pattern shift speed.</li>
              <li><strong>Scale Factor Slider</strong>: Range 0 to 200. Sets cell size.</li>
              <li><strong>Cell Size Slider</strong>: Range 0.01 to 0.2. Sets cell density.</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- CSS for Modal -->
<style>
  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    overflow: auto;
  }
  .modal-content {
    background-color: #1a1a1a;
    margin: 10% auto;
    padding: 20px;
    border: 1px solid #333;
    width: 80%;
    max-width: 800px;
    border-radius: 8px;
    color: #e0e0e0;
    position: relative;
  }
  .close {
    color: #aaa;
    position: absolute;
    top: 10px;
    right: 20px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }
  .close:hover {
    color: #fff;
  }
  h1 {
    text-align: center;
    color: #00ffff;
    margin-bottom: 20px;
  }
  .section {
    margin-bottom: 10px;
  }
  .section h2 {
    background: #333;
    padding: 10px;
    cursor: pointer;
    border-radius: 4px;
    margin: 0;
  }
  .section h2:hover {
    background: #444;
  }
  .content {
    display: none;
    padding: 10px;
    background: #222;
    border-radius: 0 0 4px 4px;
  }
  .content ul {
    list-style-type: none;
    padding: 0;
  }
  .content li {
    margin-bottom: 10px;
  }
  .content ul ul {
    margin-left: 20px;
  }



/* Ensure cursor is visible over the entire modal */
#helpModal {
    cursor: auto !important;
}

#helpModal * {
    cursor: auto !important;
}


</style>

<!-- JavaScript for Modal Functionality -->
<script>
  // Show/Hide Modal
  function showHelpModal() {
    document.getElementById('helpModal').style.display = 'block';
  }
  function hideHelpModal() {
    document.getElementById('helpModal').style.display = 'none';
  }
  // Close Modal on Outside Click
  window.onclick = function(event) {
    if (event.target == document.getElementById('helpModal')) {
      hideHelpModal();
    }
  }
  // Toggle Roll-Down Sections
  document.querySelectorAll('.section h2').forEach(header => {
    header.addEventListener('click', () => {
      const content = header.nextElementSibling;
      content.style.display = content.style.display === 'block' ? 'none' : 'block';
    });
  });
  // Attach to Documentation Button (assumed to have id="documentationButton")
  document.getElementById('documentationButton').addEventListener('click', showHelpModal);
  // Close Button
  document.querySelector('.close').addEventListener('click', hideHelpModal);
</script>









</body>
</html>